{"version":11,"variables":[{"key":"Scope","type":"code","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  const config = { schemaIds: 'builtin:management-zones'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  let managementZones = objects.items.map(el => el.value.name);\n  managementZones = [\"Tenant\", ...managementZones]\n  return managementZones;\n}","multiple":true},{"key":"Indicators","type":"csv","input":"All,fullStackCoverage,candidates,hostGroups,hostGroupCoverage,uniqueProcessGroups,declarativeProcessGroupings,uniqueServices,customServices,osServices,serviceKeyRequests,calculatedServiceMetrics,webApps,androidApps,iosApps,userTagCoverage,uscm,syntheticMonitors,managementZones,autoTags,manualTags,alertingProfiles,integrations,integrationTypes,metricEvents,slos,releaseIntegrations,logMonitoring,thirdPartyVulnerabilityAnalytics,codeLevelVulnerabilityAnalytics,runtimeApplicationProtection,dashboards,notebooks,cloudIntegrations,extensions,extensionConfigurations,networkZones,ownershipTeams,auditLogs,oneAgentVersions,activeGateVersions","multiple":true}],"tiles":{"0":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators\n  if($Indicators[0] === \"All\" ||\n     $Indicators.includes(\"fullStackCoverage\") ||\n     $Indicators.includes(\"candidates\") ||\n     $Indicators.includes(\"hostGroups\") ||\n     $Indicators.includes(\"hostGroupCoverage\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false)';\n    } else {\n      entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),mzName(${scope})`;\n    }\n    const config = { from: `now-1d`, entitySelector: entitySelector};\n    // Get all monitored hosts\n    const objects = await monitoredEntitiesClient.getEntities(config);\n    // Return the count\n    return objects.totalCount;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":" Hosts","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"3":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"hostGroups\") || $Indicators.includes(\"hostGroupCoverage\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST_GROUP\")';\n    } else {\n      entitySelector = `type(\"HOST_GROUP\"),toRelationships.isInstanceOf(type(\"HOST\"),mzName(${scope}))`;\n    }\n    const config = { from: `now-1d`, entitySelector: entitySelector};\n    // Get all host groups\n    const objects = await monitoredEntitiesClient.getEntities(config);\n    // Format results for table visualization\n    const hostGroups = objects.entities.map(el => {\n      const filteredHostGroupEntry = {};\n      filteredHostGroupEntry[\"Host group\"] = el.displayName;\n      return filteredHostGroupEntry;\n    });\n    // Return the list\n    return hostGroups.length > 0 ? hostGroups : { \"Host group\": \"‚ö†Ô∏è No host group defined\"};\n  } else {\n    return { \"Host group\": \"N/A\"};\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"host groups","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"5":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"hostGroups\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Get all host groups\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST_GROUP\")';\n    } else {\n      entitySelector = `type(\"HOST_GROUP\"),toRelationships.isInstanceOf(type(\"HOST\"),mzName(${scope}))`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    const hostGroups = await monitoredEntitiesClient.getEntities(config);\n    // Get all Web apps\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    // Get all mobile apps\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    // Get all custom apps\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    // Compute ratio between number of host groups and monitored apps\n    const hostGroupAppRatio = hostGroups.totalCount/(webApps.totalCount + mobileApps.totalCount + customApps.totalCount);\n    // Compute local score based on the above ratio\n    const score = hostGroupAppRatio >= 1 ? 1 : (hostGroupAppRatio >= 0.8 ? 0.5 : 0);\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${hostGroups.totalCount}`;\n        break;\n      case score === 0.5:\n        result = `üí° ${hostGroups.totalCount}`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è ${hostGroups.totalCount}`;\n        break;\n    }\n    // Return the emojied result\n    return result;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Host groups","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"8":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"hostGroups\") || $Indicators.includes(\"hostGroupCoverage\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false),not(fromRelationships.isInstanceOf(type(\"HOST_GROUP\")))';\n    } else {\n      entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),not(fromRelationships.isInstanceOf(type(\"HOST_GROUP\"))),mzName(${scope})`;\n    }\n    const config = { from: `now-1d`, entitySelector: entitySelector};\n    // Get all hosts with no host group\n    const objects = await monitoredEntitiesClient.getEntities(config);\n    // Format results for table visualization\n    const hostsWithNoHostGroup = objects.entities.map(el => {\n    const filteredEntry = {};\n      filteredEntry[\"Host with no host group\"] = `‚ö†Ô∏è ${el.displayName}`;\n      return filteredEntry;\n    });\n    // Return list\n    return hostsWithNoHostGroup.length > 0 ? hostsWithNoHostGroup : { \"Host with no host group\": \"‚úÖ All hosts are associated to a group\"};\n  } else {\n    return { \"Host with no host group\": \"N/A\"};\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"host group coverage","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["Hosts with no host group:"]]}}},"9":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"uniqueProcessGroups\") || $Indicators.includes(\"declarativeProcessGroupings\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"PROCESS_GROUP\")';\n    } else {\n      entitySelector = `type(\"PROCESS_GROUP\"),mzName(${scope})`;\n    }\n    const config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all process groups\n    const objects = await monitoredEntitiesClient.getEntities(config);\n    // Return count\n    return objects.totalCount;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Process groups","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"11":{"type":"markdown","title":"","content":" "},"12":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" ||\n     $Indicators.includes(\"uniqueServices\") ||\n     $Indicators.includes(\"customServices\") ||\n     $Indicators.includes(\"osServices\") ||\n     $Indicators.includes(\"serviceKeyRequests\") ||\n     $Indicators.includes(\"calculatedServiceMetrics\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SERVICE\")';\n    } else {\n      entitySelector = `type(\"SERVICE\"),mzName(${scope})`;\n    }\n    const config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all services\n    const objects = await monitoredEntitiesClient.getEntities(config);\n    // Return count\n    return objects.totalCount;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Services","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"13":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"uniqueServices\") || $Indicators.includes(\"customServices\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SERVICE\")';\n    } else {\n      entitySelector = `type(\"SERVICE\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector, sort: \"name\", pageSize: 12000 };\n    // Get all services\n    let objects = await monitoredEntitiesClient.getEntities(config);\n    let services = objects.entities.map(el => {\n  return {\n    \"Service\": el.displayName,\n    \"Duplicate\": `‚úÖ NO`,\n    entityId: el.entityId\n  };\n});\nwhile(objects.nextPageKey) {\n  config = { nextPageKey: objects.nextPageKey };\n  objects = await monitoredEntitiesClient.getEntities(config);\n  const otherServices = objects.entities.map(el => {\n    return {\n      \"Service\": el.displayName,\n      \"Duplicate\": `‚úÖ NO`,\n      entityId: el.entityId\n    };\n  });\n  services = [...services, ...otherServices];\n}\n// Helper function to filter duplicates\nconst lookup = services.reduce((a, e) => {\n  a[e[\"Service\"]] = ++a[e[\"Service\"]] || 0;\n  return a;\n}, {});\nlet duplicateServices = [];\nlet uniqueServices = [];\n// Segment unique and duplicate services\nfor(let service of services) {\n  if(lookup[service[\"Service\"]]) {\n    service[\"Duplicate\"] = `‚ö†Ô∏è YES`;\n    duplicateServices.push(service);\n  } else {\n    uniqueServices.push(service);\n  }\n}\n// List duplicate services first, unique ones second\nconst allServices = [...duplicateServices, ...uniqueServices];\n// List services\nreturn allServices.length > 0 ? allServices.slice(0, 500) : { \"Service\": \"‚ö†Ô∏è No service detected\"};\n  } else {\n    return { \"Service\": \"N/A\"};\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"services","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"14":{"type":"markdown","title":"","content":" "},"17":{"type":"markdown","title":"","content":" "},"19":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"webApps\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n  let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    const config = { from: `now-7d`, entitySelector: entitySelector};\n    const objects = await monitoredEntitiesClient.getEntities(config);\n    const score = (objects.entities.some(el => el.displayName === \"My web application\") || objects.totalCount === 0) ? 0 : 1;\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${objects.totalCount}`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è ${objects.totalCount}`;\n        break;\n    }\n   // Return the emojied result\n   return result;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Web","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"20":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"androidApps\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n  let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all Web apps\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all mobile apps\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all custom apps\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    const apps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"ANDROID\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"ANDROID\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get Android apps\n    const androidApps = await monitoredEntitiesClient.getEntities(config);\n    // Compute ratio between Android apps and all apps\n    const androidAppRatio = androidApps.totalCount / apps;\n    // Compute local score based on above ratio\n    const score = androidAppRatio >= 0.05 ? 1 : 0;\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${androidApps.totalCount}`;\n        break;\n      case score === 0:\n        result = `üí° ${androidApps.totalCount}`;\n        break;\n    }\n   // Return the emojied result\n   return result;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Android","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"22":{"type":"markdown","title":"","content":" "},"23":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"managementZones\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    let mz = [];\n    if(scope === \"Tenant\") {\n      const config = { schemaIds: 'builtin:management-zones'};\n      // Get all management zones\n      const objects = await settingsObjectsClient.getSettingsObjects(config);\n      mz = objects.items;\n    } else {\n      for(let scope of $Scope) {\n        mz.push({ value: { name: scope } });\n      }\n    }\n    // Format data for table visualization\n    const managementZones = mz.map(el => {\n      const filteredEntry = {};\n      filteredEntry[\"Management zone\"] = el.value.name;\n      return filteredEntry;\n    });\n    // Return list\n    return managementZones.length > 0 ? managementZones : { \"Management zone\": \"‚ö†Ô∏è No management zone detected\"};\n  } else {\n    return { \"Management zone\": \"N/A\"};\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"management zones","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"24":{"type":"code","title":"","input":"import { settingsObjectsClient, monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"managementZones\")) {\n  let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    let mz = {};\n    if(scope === \"Tenant\") {\n      let config = { schemaIds: 'builtin:management-zones'};\n      // Get management zones\n      mz = await settingsObjectsClient.getSettingsObjects(config);\n    } else {\n      mz.totalCount = $Scope.length;\n    }\n    // Define entity selector based on the selected scope\n  let entitySelector;\n    // Count monitored apps\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    // Compute count of monitored apps\n    const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n    config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")', fields: 'managementZones', pageSize: 500};\n    // Get apps and their management zones\n    const objects = await monitoredEntitiesClient.getEntities(config);\n    // List apps with no management zone\n    const appsWithNoMz = objects.entities.filter(el => el.managementZones.length === 0);\n    // Compute local score based on the number of apps with no management zone\n    const score = appsWithNoMz.length === 0 ? 1 : 0;\n    if(scope === \"Tenant\") {\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${mz.totalCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${mz.totalCount}`;\n          break;\n      }\n     // Return the emojied result\n     return result;\n    } else {\n      return mz.totalCount;\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Management zones","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"25":{"type":"markdown","title":"","content":"Full-Stack monitoring your entire IT landscape and defining host groups correctly enable Davis AI to precisely detect anomalies, alert the right people and launch auto-remediation confidently.\n\nThe [monitoring candidates](https://www.dynatrace.com/support/help/get-started/glossary#glossary-monitoring-candidates) screen helps you list hosts communicating with monitored servers, where the OneAgent should be deployed for complete Smartscape¬Æ topology discovery and observability.\n\n[Full-Stack monitoring](https://www.dynatrace.com/support/help/shortlink/infrastructure#full-stack-monitoring) mode should be enabled on all hosts where some app code is running to benefit from the unique PurePath¬Æ distributed tracing technology, automated RUM and much more. Servers purely dedicated to database should be monitored in Infra-Only mode to optimize costs.\n\nIt's best practice to assign a [host group](https://www.dynatrace.com/support/help/shortlink/host-groups) to the subset of hosts running each monitored app/dev stage (eg. myapp-staging). This automates the correct segmentation of process groups and services and maximize. the accuracy of the answers provided by the platform"},"26":{"type":"markdown","title":"","content":"Dynatrace automatically merges related processes into process groups. A ‚Äúprocess group‚Äù is a logical cluster of processes that belong to the same application or deployment unit and perform the same function across multiple hosts.\n\nThe use of [host groups](https://www.dynatrace.com/support/help/shortlink/host-groups) automatically segments your process groups according to each application and dev stage.\n\nDeclarative process grouping rules enable the [deep monitoring](https://www.dynatrace.com/support/help/shortlink/process-groups) of unknown tech or low-consuming processes to extend your observability.\n\nIt's recommended to automate your naming convention by leveraging [process group naming rules](https://www.dynatrace.com/support/help/shortlink/process-group-naming)."},"27":{"type":"code","title":"","input":"import { settingsObjectsClient, monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"declarativeProcessGroupings\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:declarativegrouping'};\n      // Get declarative grouping rules\n      const declarativeGroupings = await settingsObjectsClient.getSettingsObjects(config);\n      config = { from: `now-1d`, entitySelector: 'type(\"PROCESS_GROUP\")'};\n      // Get all process groups\n      const processGroups = await monitoredEntitiesClient.getEntities(config);\n      // Compute the ratio between process declarative grouping ules and process groups\n      const declarativeGroupingRatio = declarativeGroupings.totalCount / processGroups.totalCount;\n      // Compute local score based on above ratio\n      const score = declarativeGroupingRatio > 0.0001 ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${declarativeGroupings.totalCount}`;\n          break;\n        case score === 0:\n          result = `üí° ${declarativeGroupings.totalCount}`;\n          break;\n      }\n      // Return the emojied result\n      return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Declarative process groupings","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"28":{"type":"markdown","title":"","content":"The OneAgent in Full-Stack mode automatically instruments your application code. This lets Dynatrace give you end-to-end visibility on the performance, availability and security of your services.\n\n[Service detection rules](https://www.dynatrace.com/support/help/shortlink/rule-based-service-detection) improve out-of-the-box detection when needed.\n\nThe creation of [custom services](https://www.dynatrace.com/support/help/platform-modules/applications-and-microservices/services/service-detection-and-naming/service-types/custom-services) helps model message queue handlers (Kafka,‚Ä¶) or other application services that couldn't be recognized out-of-the-box.\n\nMore accurate names can be assigned to monitored services by defining [service naming rules](https://www.dynatrace.com/support/help/shortlink/custom-service-names).\n\nIt's critical to monitor the health of [OS services](https://www.dynatrace.com/support/help/platform-modules/infrastructure-monitoring/hosts/monitoring/os-services) as they are the backbone of many of your own services.\n\nWe recommend promoting your most important backend requests as service [Key Requests](https://www.dynatrace.com/support/help/platform-modules/applications-and-microservices/services/analysis/monitor-key-requests) to benefit from extensive, high-fidelity and long-term analysis and alerting on those business-critical transactions."},"29":{"type":"markdown","title":"","content":"In RUM, monitored applications are logical constructs onto which customer applications‚Äîwebsites, mobile apps, and more‚Äîare mapped for monitoring with regard to traffic from real users. Therefore, it's implied that such customer applications have an end-user interface.\n\nWe recommend letting the Full-Stack OneAgent [manage RUM automatically](https://www.dynatrace.com/support/help/platform-modules/digital-experience/web-applications/initial-setup/rum-injection#automatic-injection) for you.\n\nThe definition of [app detection rules](https://www.dynatrace.com/support/help/shortlink/my-web-application) is required to segment your RUM strategy per domain (recommended) or URL (alternative). Once they are defined, it's important to verify that the placeholder \"My web application\" RUM app doesn't capture any more traffic.\n\nAutomatic [user action naming rules](https://www.dynatrace.com/support/help/shortlink/custom-names) make AI answers more relevant to you."},"30":{"type":"markdown","title":"","content":"Dynatrace Synthetic Monitoring makes it easy for you to monitor the availability and performance of your applications as experienced by your customers around the world and around the clock.\n\nWe recommend you monitor the Top3 most business-critical user scenarios and backend endpoints of each application with [synthetic tests](https://www.dynatrace.com/support/help/platform-modules/digital-experience/synthetic-monitoring).\n\nTo benefit from complete causality from Davis AI, it's important to [assign](https://www.dynatrace.com/support/help/platform-modules/digital-experience/synthetic-monitoring/browser-monitors/configure-browser-monitors#assigned-applications) each browser monitor to its corresponding RUM application."},"32":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"candidates\")) {\n    if($Scope[0] === \"Tenant\") {\n      // Get all monitored hosts\n      let config = { from: `now-1d`, entitySelector: 'type(\"HOST\"),isMonitoringCandidate(false)'};\n      const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n      // Get all hosts candidate for monitoring\n      config = { from: `now-1d`, entitySelector: 'type(\"HOST\"),isMonitoringCandidate(true)'};\n      const monitoringCandidates = await monitoredEntitiesClient.getEntities(config);\n      // Compute local score based on the number of candidates\n      const score = monitoringCandidates.totalCount === 0 ? 1 : (monitoringCandidates.totalCount < 50 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${monitoringCandidates.totalCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${monitoringCandidates.totalCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${monitoringCandidates.totalCount}`;\n          break;\n      }\n      // Return the emojied result\n      return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Candidates","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"35":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"customServices\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SERVICE\")';\n    } else {\n      entitySelector = `type(\"SERVICE\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all services\n    const services = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SERVICE\"),serviceType(\"CUSTOM_SERVICE\")';\n    } else {\n      entitySelector = `type(\"SERVICE\"),serviceType(\"CUSTOM_SERVICE\"),mzName(${scope})`;\n    }\n    config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all custom services\n    const customServices = await monitoredEntitiesClient.getEntities(config);\n    // Compute ratio between custom services and all services\n    const customServiceRatio = customServices.totalCount / services.totalCount;\n    // Compute local score based on above ratio\n    const score = customServiceRatio > 0.01 ? 1 : (customServiceRatio >= 0.001 ? 0.5 : 0);\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${customServices.totalCount}`;\n        break;\n      case score === 0.5:\n        result = `üí° ${customServices.totalCount}`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è ${customServices.totalCount}`;\n        break;\n    }\n    // Return the emojied result\n    return result;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Custom services","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"38":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"iosApps\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n  let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all Web apps\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all mobile apps\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all custom apps\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    const apps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"IOS\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"IOS\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all iOS apps\n    const iosApps = await monitoredEntitiesClient.getEntities(config);\n    // Compute the ratio between iOS apps and all apps\n    const iosAppRatio = iosApps.totalCount / apps;\n    // Compute local score based on above ratio\n    const score = iosAppRatio >= 0.05 ? 1 : 0;\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${iosApps.totalCount}`;\n        break;\n      case score === 0:\n        result = `üí° ${iosApps.totalCount}`;\n        break;\n    }\n   // Return the emojied result\n   return result;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"ios","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"39":{"type":"code","title":"(with traffic in the past 7 days)","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"webApps\") || $Indicators.includes(\"iosApps\") || $Indicators.includes(\"androidApps\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all Web apps\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all mobile apps\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all custom apps\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    // Return count of all monitored apps\n    return webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Apps","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"42":{"type":"code","title":"","input":"import { settingsObjectsClient, monitoredEntitiesClient, metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\nimport { rumUserSessionsClient } from \"@dynatrace-sdk/client-classic-environment-v1\";\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"webApps\")) {\n    // Get list of app IDs and names\n    let config = { schemaIds: 'builtin:rum.web.name', fields: 'value, scope', pageSize: 500 };\n    let objects = await settingsObjectsClient.getSettingsObjects(config);\n    const webApps = [];\n    // Prepare template object for each monitored Web app\n    for(let object of objects.items) {\n      webApps.push({\n        id: object.scope,\n        'Web app name': object.value.applicationName === \"My web application\" ? \"‚ö†Ô∏è My web application ‚ö†Ô∏è\" : object.value.applicationName,\n        '7-day traffic': object.value.applicationName === 'My web application' ? \"‚úÖ NO\" : \"‚ö†Ô∏è NO\",\n        RUM: \"‚úÖ ON\",\n        'Synthetic tests': \"‚ö†Ô∏è 0\",\n        'User tags': \"üí° NO\",\n        'Key User Actions': 0,\n        Properties: 0,\n        Conversions: \"üí° NO\",\n        'Session Replay': \"üí° OFF\",\n        'App detection rules': \"\",\n        'JS agent version': \"LATEST_STABLE\"\n      })\n    }\n    // Collect non-default settings for RUM and Session Replay enablement\n    config.schemaIds = 'builtin:rum.web.enablement';\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n    for(let object of objects.items) {\n      let webAppIndex = webApps.findIndex(el => el.id === object.scope);\n      if(webAppIndex > -1) {\n        webApps[webAppIndex].RUM = object.value.rum.enabled ? \"‚úÖ ON\" : \"‚ö†Ô∏è OFF\";\n        webApps[webAppIndex]['Session Replay'] = object.value.sessionReplay.enabled ? \"‚úÖ ON\" : \"üí° OFF\";\n      }\n    }\n    // Count associated synthetic tests for each Web app\n    for(let i=0; i < webApps.length; i++) {\n      let config = { from: \"now-1d\", entitySelector: `type(\"SYNTHETIC_TEST\"),fromRelationships.monitors(type(\"APPLICATION\"),entityId(\"${webApps[i].id}\"))`};\n      const objects = await monitoredEntitiesClient.getEntities(config);\n      let result;\n      switch(true) {\n        case objects.totalCount == 0:\n          result = `‚ö†Ô∏è ${objects.totalCount}`;\n          break;\n        case objects.totalCount < 2:\n          result = `üí° ${objects.totalCount}`;\n          break;\n        default:\n          result = `‚úÖ ${objects.totalCount}`;\n      }\n      webApps[i]['Synthetic tests'] = result;\n    }\n    // Collect user tag rules\n    let userTaggedApps = await rumUserSessionsClient.getUsqlResultAsTable({\n      query: \"SELECT application FROM useraction WHERE (usersession.userId IS NOT NULL) GROUP BY application LIMIT 500\",\n      startTimestamp: (Date.now() - 7*24*60*60*1000),\n      pageSize: 500\n    });\n    userTaggedApps = userTaggedApps.values;\n    for(let userTaggedApp of userTaggedApps) {\n      let webAppIndex = webApps.findIndex(el => el['Web app name'] === userTaggedApp[0]);\n      if(webAppIndex > -1) {\n        webApps[webAppIndex]['User tags'] = `‚úÖ YES`;\n      }\n    }\n    // Collect app detection rules\n    config.schemaIds = 'builtin:rum.web.app-detection';\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n    for(let object of objects.items) {\n      let webAppIndex = webApps.findIndex(el => el.id === object.value.applicationId);\n      if(webAppIndex > -1) {\n        webApps[webAppIndex]['App detection rules'] = webApps[webAppIndex]['App detection rules'] ? `${webApps[webAppIndex]['App detection rules'] + object.value.matcher} ${object.value.pattern}; ` : `${object.value.matcher} ${object.value.pattern}; `;\n      }\n    }\n    for(let i=0; i < webApps.length; i++) {\n      webApps[i]['App detection rules'] = webApps[i]['App detection rules'] ? webApps[i]['App detection rules'] : \"‚ö†Ô∏è NO RULES\";\n    }\n    // Collect Javascript agent version settings\n    config.schemaIds = 'builtin:rum.web.rum-javascript-updates';\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n    let envJsUpdatesIndex = objects.items.findIndex(el => el.scope === \"environment\");\n    if(envJsUpdatesIndex > -1) {\n      for(let i=0; i < webApps.length; i++) {\n        webApps[i]['JS agent version'] = objects.items[envJsUpdatesIndex].value.JavascriptVersion;\n      }\n    }\n    for(let object of objects.items) {\n      let webAppIndex = webApps.findIndex(el => el.id === object.scope);\n      if(webAppIndex > -1) {\n        webApps[webAppIndex]['JS agent version'] = object.value.JavascriptVersion;\n      }\n    }\n    // Determine which apps received traffic in the last 7 days\n    config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n    objects = await monitoredEntitiesClient.getEntities(config);\n    for(let object of objects.entities) {\n      let webAppIndex = webApps.findIndex(el => el.id === object.entityId);\n      if(webAppIndex > -1) {\n        webApps[webAppIndex]['7-day traffic'] = webApps[webAppIndex]['Web app name'] === '‚ö†Ô∏è My web application ‚ö†Ô∏è' ? \"‚ö†Ô∏è YES\" : \"‚úÖ YES\";\n      }\n    }\n    // For each app, determine which key user actions received traffic in the last 7 days\n    config = { from: \"now-7d\", fields: '+fromRelationships', entitySelector: 'type(application_method)'};\n    objects = await monitoredEntitiesClient.getEntities(config);\n    for(let object of objects.entities) {\n      if(object.fromRelationships.isApplicationMethodOf) {\n        let webAppIndex = webApps.findIndex(el => el.id === object.fromRelationships.isApplicationMethodOf[0].id);\n        if(webAppIndex > -1) {\n          webApps[webAppIndex]['Key User Actions']++;\n        }\n      }\n    }\n    // For each app, determine how many user action and session properties got captured in the last 7 days\n    config = { from: \"now-7d\", acceptType: \"application/json; charset=utf-8\", metricSelector: 'builtin:billing.apps.web.userActionPropertiesByApplication:splitBy(\"dt.entity.application\"):sort(value(auto,descending)):limit(100):fold(value)'};\n    objects = await metricsClient.query(config);\n     for(let object of objects.result) {\n      let webAppIndex = webApps.findIndex(el => el.id === object.data[0].dimensionMap['dt.entity.application']);\n      if(webAppIndex > -1) {\n        webApps[webAppIndex].Properties = object.data[0].values[0];\n      }\n     }\n    // For each app, determine if there's any conversion rate captured in the last 7 days\n    config = { from: \"now-7d\", acceptType: \"application/json; charset=utf-8\", metricSelector: 'builtin:apps.web.conversionRate:splitBy(\"dt.entity.application\"):sort(value(auto,descending)):limit(100):fold(value)'};\n    objects = {\n      result: []\n    };\n    try {\n     objects = await metricsClient.query(config);\n    } catch(e) {}\n    if(objects.result[0] && objects.result[0].data[0]) {\n      for(let object of objects.result) {\n        let webAppIndex = webApps.findIndex(el => el.id === object.data[0].dimensionMap['dt.entity.application']);\n        if(webAppIndex > -1) {\n          webApps[webAppIndex].Conversions = \"‚úÖ YES\";\n        }\n      }\n    }\n    \n    // If the review is scope to some management zones, filter out apps that are not part of the review scope\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    const filteredWebApps = [];\n    if(scope !== \"Tenant\") {\n      let entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n      config = { from: `now-10000d`, entitySelector: entitySelector};\n      objects = await monitoredEntitiesClient.getEntities(config);\n      for(let object of objects.entities) {\n        filteredWebApps.push(webApps.find(el => el.id === object.entityId));\n      }\n    }\n    \n  \n    // Remove the app IDs from the final output\n    for(let i=0; i < webApps.length; i++) {\n      delete webApps[i].id;\n    }\n    // Return list\n    if(scope === \"Tenant\") {\n      return webApps.length > 0 ? webApps : { \"Web app name\": \"‚ö†Ô∏è No web app detected\"};\n    } else {\n      return filteredWebApps.length > 0 ? filteredWebApps : { \"Web app name\": \"‚ö†Ô∏è No web app detected\"};\n    }\n  } else {\n    return { \"Web app name\": \"N/A\"};\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["App detection rules"]]}}},"43":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"fullStackCoverage\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST\"),monitoringMode(\"FULL_STACK\")';\n    } else {\n      entitySelector = `type(\"HOST\"),monitoringMode(\"FULL_STACK\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all Full Stack monitored hosts\n    const fullStackHosts = await monitoredEntitiesClient.getEntities(config);\n    // Define entity selector based on the selected scope\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false)';\n    } else {\n      entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),mzName(${scope})`;\n    }\n    config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all monitored hosts\n    const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n    // Compute Full Stack coverage percentage\n    const fullStackCoverage = parseInt(fullStackHosts.totalCount/monitoredHosts.totalCount*100);\n    // Compute local score based on the Full Stack coverage\n    const score = fullStackCoverage === 100 ? 1 : (fullStackCoverage >= 80 ? 0.5 : 0);\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${fullStackCoverage}%`;\n        break;\n      case score === 0.5:\n        result = `üí° ${fullStackCoverage}%`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è ${fullStackCoverage}%`;\n        break;\n    }\n    // Return the emojied result\n    return result; \n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Full stack coverage","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"44":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"hostGroupCoverage\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false)';\n    } else {\n      entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),mzName(${scope})`;\n    }\n    let config = { from: `now-1d`, entitySelector: entitySelector};\n    // Get all monitored hosts\n    const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n    // Define entity selector based on the selected scope\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false),fromRelationships.isInstanceOf(type(\"HOST_GROUP\"))';\n    } else {\n      entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),fromRelationships.isInstanceOf(type(\"HOST_GROUP\")),mzName(${scope})`;\n    }\n    config = { from: `now-1d`, entitySelector: entitySelector};\n    // Get all monitored hosts that are assigned with a host group\n    const hostsWithHostGroup = await monitoredEntitiesClient.getEntities(config);\n    // Compute host group coverage\n    const hostGroupCoverage = parseInt(hostsWithHostGroup.totalCount/monitoredHosts.totalCount*100);\n    // Compute local score based on the host group coverage\n    const score = hostGroupCoverage === 100 ? 1 : (hostGroupCoverage >= 80 ? 0.5 : 0);\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${hostGroupCoverage}%`;\n        break;\n      case score === 0.5:\n        result = `üí° ${hostGroupCoverage}%`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è ${hostGroupCoverage}%`;\n        break;\n    }\n    // Return the emojied result\n    return result;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Host group coverage","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"46":{"type":"code","title":"(with executions in the past 7 days)","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"syntheticMonitors\")) {\n    // List all synthetic monitors\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SYNTHETIC_TEST\")';\n    } else {\n      entitySelector = `type(\"SYNTHETIC_TEST\"),mzName(${scope})`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all synthetic monitors\n    const objects = await monitoredEntitiesClient.getEntities(config);\n    // Count monitored apps\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n    // Compute the ratio between synthetic monitors and monitored apps\n    const syntheticRatio = objects.totalCount / monitoredApps;\n    // Compute local score based on above ratio\n    const score = syntheticRatio >= 3 ? 1 : (syntheticRatio >= 1 ? 0.5 : 0);\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${objects.totalCount}`;\n        break;\n      case score === 0.5:\n        result = `üí° ${objects.totalCount}`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è ${objects.totalCount}`;\n        break;\n    }\n   // Return the emojied result\n   return result;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Synthetic monitors","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"47":{"type":"code","title":"","input":"import { settingsObjectsClient, monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"syntheticMonitors\")) {\n    // List all synthetic monitors\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SYNTHETIC_TEST\")';\n    } else {\n      entitySelector = `type(\"SYNTHETIC_TEST\"),mzName(${scope})`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all synthetic monitors\n    let objects = await monitoredEntitiesClient.getEntities(config);\n    const syntheticMonitors = [];\n    for(let object of objects.entities) {\n      syntheticMonitors.push({\n        'Monitor name': object.displayName,\n        'Outage handling': \"‚úÖ YES\",\n        entityId: object.entityId\n      })\n    }\n    // Collect scheduling settings\n    config = { schemaIds: 'builtin:synthetic.browser.scheduling', fields: 'value, scope', pageSize: 500 };\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n    for(let object of objects.items) {\n      let syntheticMonitorIndex = syntheticMonitors.findIndex(el => el.id === object.scope);\n      if(syntheticMonitorIndex > -1) {\n        syntheticMonitors[syntheticMonitorIndex].locations = object.value.locations.length > 1 ? `‚úÖ ${object.value.locations.length}` : `üí° ${object.value.locations.length}`\n        syntheticMonitors[syntheticMonitorIndex].frequency = object.value.frequency > 15 ? `üí° ${object.value.frequency}` : `‚úÖ ${object.value.frequency}`\n      }\n    }\n    // Collect outage handling settings\n    config = { schemaIds: 'builtin:synthetic.browser.outage-handling', fields: 'value, scope', pageSize: 500 };\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n    for(let object of objects.items) {\n      let syntheticMonitorIndex = syntheticMonitors.findIndex(el => el.id === object.scope);\n      if(syntheticMonitorIndex > -1) {\n        syntheticMonitors[syntheticMonitorIndex].outageHandling = object.value.globalOutages ? \"‚úÖ YES\" : \"‚ö†Ô∏è NO\";\n      }\n    }\n    // Return list\n    return syntheticMonitors.length > 0 ? syntheticMonitors : { \"Monitor name\": \"‚ö†Ô∏è No synthetic monitor detected\"};\n  } else {\n    return { \"Monitor name\": \"N/A\"};\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"48":{"type":"markdown","title":"","content":"Management zones are a powerful information-partitioning mechanism that promote focus on specific parts of your observed topology and the sharing of relevant team-specific data while simultaneously ensuring secure access control.\n\nIt's recommended to create one [management zone](https://www.dynatrace.com/support/help/shortlink/management-zones) per application & dev stage (e.g. ‚Äú[app] easytravel.staging‚Äù)\n\nManagement zones can overlap to better segment your analysis of monitored entities (eg. [env] staging).\n\nUser groups permit the assignment of [management-zone-level read/write permissions](https://www.dynatrace.com/support/help/manage/access-control/user-management-and-sso/manage-user-permissions-roles#mz) to the teams relevant to each monitoring scope."},"49":{"type":"markdown","title":"","content":" "},"50":{"type":"code","title":"","input":"import { settingsObjectsClient, monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"autoTags\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:tags.auto-tagging'};\n      // Get all auto tags\n      let objects = await settingsObjectsClient.getSettingsObjects(config);\n      // Compute local score based on the number of auto tags\n      const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 3 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${objects.totalCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${objects.totalCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${objects.totalCount}`;\n          break;\n      }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Auto tags","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"51":{"type":"markdown","title":"","content":" "},"52":{"type":"markdown","title":"","content":" "},"53":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"autoTags\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { schemaIds: 'builtin:tags.auto-tagging', pageSize: 500 };\n      // Get all auto tags\n      const objects = await settingsObjectsClient.getSettingsObjects(config);\n      const autoTags = objects.items.map(el => {\n        const filteredEntry = {};\n        filteredEntry[\"Auto-tag\"] = el.value.name;\n        return filteredEntry;\n      });\n      // Return list\n      return autoTags.length > 0 ? autoTags : { \"Auto-tag\": \"No auto-tag detected\"};\n      } else {\n        return {\n          \"Auto-tag\": `N/A`\n        };\n      }\n  } else {\n    return {\n      \"Auto-tag\": `N/A`\n    };\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"management zones","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"54":{"type":"markdown","title":"","content":"Tags enable you to organize your monitored environments in a meaningful way. Tags in Dynatrace are labels that you attach to monitored entities and reuse in most screens and APIs of the platform.\n\nIt's best practice to implement [automatic tagging](https://www.dynatrace.com/support/help/manage/tags-and-metadata/setup/how-to-define-tags#automatic) whenever possible and meaningful.\n\nUse [manual tagging](https://www.dynatrace.com/support/help/manage/tags-and-metadata/setup/how-to-define-tags#manual) for scenarios where there‚Äôs no common denominator for performing accurate auto-tagging.\n\nFollowing a collective tag naming convention helps [making best use of them](https://www.dynatrace.com/support/help/manage/tags-and-metadata/basic-concepts/best-practices-and-recommendations-for-tagging) throughout the Platform."},"55":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"alertingProfiles\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:management-zones'};\n      // Get all management zones\n      const mz = await settingsObjectsClient.getSettingsObjects(config);\n      config = { schemaIds: 'builtin:alerting.profile'};\n      // Get all alerting profiles\n      const alertingProfiles = await settingsObjectsClient.getSettingsObjects(config);\n      // Compute the ratio of management zones per alerting profile and corresponding local score\n      const score = alertingProfiles.totalCount >= mz.totalCount ? 1 : (alertingProfiles.totalCount >= 5 ? 0.5 : 0);\n      let result;\n        switch(true) {\n        case score === 1:\n          result = `‚úÖ ${alertingProfiles.totalCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${alertingProfiles.totalCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${alertingProfiles.totalCount}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Alerting profiles","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"56":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"integrations\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:problem.notifications'};\n      // Get all problem notifications set up\n      const integrations = await settingsObjectsClient.getSettingsObjects(config);\n      config = { schemaIds: 'builtin:alerting.profile'};\n      // Get all alerting profiles\n      const alertingProfiles = await settingsObjectsClient.getSettingsObjects(config);\n      // Compute the number of notification pipelines per alerting profile, and corresponding local score\n      const score = integrations.totalCount >= alertingProfiles.totalCount * 1.5 ? 1 : (integrations.totalCount >= alertingProfiles.totalCount ? 0.5 : 0);\n      let result;\n        switch(true) {\n        case score === 1:\n          result = `‚úÖ ${integrations.totalCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${integrations.totalCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${integrations.totalCount}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Integrations","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"57":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nfunction onlyUnique(value, index, array) {\n  return array.indexOf(value) === index;\n}\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"integrationTypes\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:problem.notifications'};\n      // Get all problem notifications set up\n      const objects = await settingsObjectsClient.getSettingsObjects(config);\n      // Retrieve the integration type of each notification configuration\n      let integrationTypes = [];\n      for(let object of objects.items) {\n        integrationTypes.push(object.value.type);\n      }\n      // Count the number of unique integration type\n      integrationTypes = integrationTypes.filter(onlyUnique);\n      // Compute local score based on above number\n      const score = integrationTypes.length >= 5 ? 1 : (integrationTypes.length >= 2 ? 0.5 : 0);\n      let result;\n        switch(true) {\n        case score === 1:\n          result = `‚úÖ ${integrationTypes.length}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${integrationTypes.length}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${integrationTypes.length}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Integration types","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"58":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"metricEvents\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:anomaly-detection.metric-events', pageSize: 500};\n      // Get all metric events\n      let objects = await settingsObjectsClient.getSettingsObjects(config);\n      let metricEvents = objects.items;\n      while(objects.nextPageKey) {\n        config = { nextPageKey: objects.nextPageKey };\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n        metricEvents = [...metricEvents, ...objects.items];\n      }\n      // Filter the enabled metric events\n      const enabledMetricEventCount = metricEvents.filter(el => el.value.enabled).length;\n      // Compute local score based on above number\n      const score = enabledMetricEventCount >= 5 ? 1 : 0;\n      let result;\n        switch(true) {\n        case score === 1:\n          result = `‚úÖ ${enabledMetricEventCount}`;\n          break;\n        case score === 0:\n          result = `üí° ${enabledMetricEventCount}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Metric events","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"59":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"alertingProfiles\")) {\n    if($Scope[0] === \"Tenant\") {\n  // Collect alerting profiles\n  let config = { schemaIds: 'builtin:alerting.profile', pageSize: 500};\n  let objects = await settingsObjectsClient.getSettingsObjects(config);\n  const alertingProfiles = [];\n  for(let object of objects.items) {\n    let severityLevels = [];\n    for(let severityRule of object.value.severityRules) {\n      severityLevels.push(severityRule.severityLevel);\n    }\n    // Evaluate each alerting profile\n    alertingProfiles.push({\n      'Alerting profile name': object.value.name,\n      'Integrations': 0,\n      'Assigned to MZ': object.value.managementZone ? \"YES\" : \"NO\",\n      'Severity levels': severityLevels.join(\",\"),\n      objectId: object.objectId\n    })\n  }\n  // Count problem notifications for each alerting profile\n  config = { schemaIds: 'builtin:problem.notifications', pageSize: 500};\n  objects = await settingsObjectsClient.getSettingsObjects(config);\n  for(let object of objects.items) {\n    let alertingProfileIndex = alertingProfiles.findIndex(el => el.objectId === object.value.alertingProfile);\n    if(alertingProfileIndex > -1) {\n      alertingProfiles[alertingProfileIndex]['Integrations']++;\n    }\n  }\n  // Format the final output\n  for(let i=0; i < alertingProfiles.length; i++) {\n    delete alertingProfiles[i].objectId;\n    alertingProfiles[i]['Integrations'] = alertingProfiles[i]['Integrations'] === 0 ? \"‚ö†Ô∏è 0\" : alertingProfiles[i]['Integrations'];\n  }\n  return alertingProfiles.length > 0 ? alertingProfiles : { \"Alerting profile name\": \"‚ö†Ô∏è No alerting profile detected\"};\n  } else {\n    return {\n      \"Alerting profile\": `N/A`\n    };\n  }\n} else {\n    return {\n      \"Alerting profile\": `N/A`\n    };\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"management zones","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["severityLevels"]]}}},"61":{"type":"code","title":"Problem severity levels from the last 7 days","input":"import { problemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"metricEvents\")) {\n    if($Scope[0] === \"Tenant\") {\n      let scope;\n      if($Scope[0] === \"Tenant\") {\n        scope = 'Tenant';\n      } else {\n        let mzList = \"\";\n        for(let i=0; i<$Scope.length; i++) {\n          mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n        }\n        scope = mzList;\n      }\n      let config;\n      if(scope === \"Tenant\") {\n        config = { from: \"now-7d\", pageSize: 500};\n      } else {\n        const problemSelector = `managementZones(${scope})`;\n        config = { from: \"now-7d\", problemSelector: problemSelector, pageSize: 500};\n      }\n      // Get all problems open in the past 7 days\n      let objects = await problemsClient.getProblems(config);\n      let problems = objects.problems;\n      while(objects.nextPageKey) {\n        config = { nextPageKey: objects.nextPageKey };\n        objects = await problemsClient.getProblems(config);\n        problems = [...problems, ...objects.problems];\n      }\n      // Format the results for graph visualization\n      const severityLevelStats = {\n        records: [],\n        types: [\n          {\n            mappings: {\n              severityLevel: {\n                type: \"string\"\n              },\n              count: {\n                type: \"long\"\n              }\n            },\n            indexRange: [\n              0,\n              1\n            ]\n          }\n        ]\n      };\n      // For each problem, increment the count of problems per severity\n      for(let problem of problems) {\n        let severityLevelIndex = severityLevelStats.records.findIndex(el => el.severityLevel === problem.severityLevel);\n        if(severityLevelIndex > -1) {\n          severityLevelStats.records[severityLevelIndex].count++;\n        } else {\n          severityLevelStats.records.push({\n            severityLevel: problem.severityLevel,\n            count: 1\n          })\n        }\n      }\n      return severityLevelStats;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"categoricalBarChart","visualizationSettings":{"chartSettings":{"gapPolicy":"connect","categoricalBarChartSettings":{"categoryAxis":"severityLevel","categoryAxisLabel":"severityLevel","valueAxis":"count","valueAxisLabel":"count"}},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":false,"lineWrapIds":[]}}},"62":{"type":"markdown","title":"","content":" "},"63":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"releaseIntegrations\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      const config = { schemaIds: 'builtin:issue-tracking.integration'};\n      try {\n        // Get all issue tracking systems integrated with Dynatrace\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Filter the enabled tracking system integrations\n      let enabledIssueTrackingSystems = 0;\n      if(objects) {\n        for(let enabledIssueTrackingSystem of objects.items) {\n          if(enabledIssueTrackingSystem.value.enabled) enabledIssueTrackingSystems++;\n        }\n      }\n      // Compute local score based on the number of tracking system integrations\n      const score = enabledIssueTrackingSystems >= 5 ? 1 : (enabledIssueTrackingSystems >= 2 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${enabledIssueTrackingSystems}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${enabledIssueTrackingSystems}`;\n          break;\n        case score === 0:\n          result = objects ? `‚ö†Ô∏è ${enabledIssueTrackingSystems}` : `‚ö†Ô∏è OFF`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Release integrations","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"64":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"slos\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      const config = { schemaIds: 'builtin:monitoring.slo'};\n      try {\n        // Get all SLOs\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Filter enabled SLOs\n      let enabledSlos = 0;\n      if(objects) {\n        for(let slo of objects.items) {\n          if(slo.value.enabled) enabledSlos++;\n        }\n      }\n      // Compute local score based on the number of enabled SLOs\n      const score = enabledSlos >= 10 ? 1 : (enabledSlos > 0 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${enabledSlos}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${enabledSlos}`;\n          break;\n        case score === 0:\n          result = objects ? `‚ö†Ô∏è ${enabledSlos}` : `‚ö†Ô∏è OFF`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"SLOs","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"65":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"thirdPartyVulnerabilityAnalytics\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      const config = { schemaIds: 'builtin:appsec.runtime-vulnerability-detection'};\n      try {\n        // Get runtime vulnerability detection settings\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Compute local score depending if runtime vulnerability detection is enabled\n      const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enableRuntimeVulnerabilityDetection ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ON`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è OFF`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"3rd party Vulnerability Analytics","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"66":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"codeLevelVulnerabilityAnalytics\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      const config = { schemaIds: 'builtin:appsec.runtime-vulnerability-detection'};\n      try {\n        // Get code-level vulnerability detection settings\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Compute local score depending if code-level vulnerability detection is enabled\n      const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enableCodeLevelVulnerabilityDetection ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ON`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è OFF`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Code-level Vulnerability Analytics","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"67":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"runtimeApplicationProtection\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      const config = { schemaIds: 'builtin:appsec.attack-protection-settings'};\n      try {\n        // Get attack protection settings\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Compute local score depending if attack protection is enabled\n      const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enabled ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ON`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è OFF`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Runtime Application Protection","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"68":{"type":"markdown","title":"","content":" "},"69":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"slos\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      let config = { schemaIds: 'builtin:monitoring.slo', pageSize: 500 };\n      try {\n        // Get all SLOs\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      let slos = objects.items.filter(el => el.value.enabled);\n      // \n      slos = slos.map(el => {\n        return {\n          'Active SLO': el.value.name,\n          'Fast burn threshold': el.value.errorBudgetBurnRate.fastBurnThreshold,\n          errorBudgetBurnRateMetricName: `func:slo.errorBudgetBurnRate.${el.value.metricName}`,\n          errorBudgetMetricName: `func:slo.errorBudget.${el.value.metricName}`,\n          normalizedErrorBudgetMetricName: `func:slo.normalizedErrorBudget.${el.value.metricName}`,\n          'Burn rate alerts': 0,\n          'Error budget alerts': 0\n        }\n      });\n      config = { schemaIds: 'builtin:anomaly-detection.metric-events', pageSize: 500 };\n      // Get all metric events\n      objects = await settingsObjectsClient.getSettingsObjects(config);\n      let metricEvents = objects.items;\n      while(objects.nextPageKey) {\n        config = { nextPageKey: objects.nextPageKey };\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n        metricEvents = [...metricEvents, ...objects.items];\n      }\n      // Filter enabled metric events\n      metricEvents = metricEvents.filter(el => el.value.enabled);\n      // For each SLO, find out if there are any metric event configured on their error budget or burn rate metrics\n      for(let slo of slos) {\n        slo['Burn rate alerts'] = metricEvents.filter(el => el.value.queryDefinition.metricSelector ? el.value.queryDefinition.metricSelector.includes(slo.errorBudgetBurnRateMetricName) : false).length;\n        slo['Burn rate alerts'] = slo['Burn rate alerts'] > 0 ? `‚úÖ ${slo['Burn rate alerts']}` : `üí° ${slo['Burn rate alerts']}`;\n        slo['Error budget alerts'] += metricEvents.filter(el => el.value.queryDefinition.metricSelector ? el.value.queryDefinition.metricSelector.includes(slo.errorBudgetMetricName) : false).length;\n        slo['Error budget alerts'] += metricEvents.filter(el => el.value.queryDefinition.metricSelector ? el.value.queryDefinition.metricSelector.includes(slo.normalizedErrorBudgetMetricName) : false).length;\n        slo['Error budget alerts'] = slo['Error budget alerts'] > 0 ? `‚úÖ ${slo['Error budget alerts']}` : `üí° ${slo['Error budget alerts']}`;\n      }\n      // Return list\n      return slos.length > 0 ? slos : { \"Active SLO\": \"‚ö†Ô∏è No active SLO detected\"};\n    } else {\n      return {\n        \"Active SLO\": `N/A`\n      };\n    }\n  } else {\n    return {\n      \"Active SLO\": `N/A`\n    };\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"active SLOs","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[["normalizedErrorBudgetMetricName"],["errorBudgetMetricName"],["errorBudgetBurnRateMetricName"]],"lineWrapIds":[]}}},"70":{"type":"code","title":"Security problem vulnerability types from the last 7 days","input":"import { securityProblemsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Retrieve the scope\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  let config;\n  if(scope === \"Tenant\") {\n    config = { from: \"now-7d\", pageSize: 500};\n  } else {\n    const securityProblemSelector = `managementZones(${scope})`;\n    config = { from: \"now-7d\", securityProblemSelector: securityProblemSelector, pageSize: 500};\n  }\n  let objects;\n  try {\n    // Get all security problems\n    objects = await securityProblemsClient.getSecurityProblems(config);\n  } catch(e) {\n    {\n      return \"N/A\";\n    }\n  }\n  let securityProblems = objects.securityProblems;\n  while(objects.nextPageKey) {\n    config = { nextPageKey: objects.nextPageKey };\n    objects = await securityProblemsClient.getSecurityProblems(config);\n    securityProblems = [...securityProblems, ...objects.securityProblems];\n  }\n  // Format the data for graph visualization\n  const vulnerabilityTypeStats = {\n    records: [],\n    types: [\n      {\n        mappings: {\n          vulnerabilityType: {\n            type: \"string\"\n          },\n          count: {\n            type: \"long\"\n          }\n        },\n        indexRange: [\n          0,\n          1\n        ]\n      }\n    ]\n  };\n  // For each problem, increment the count of security problems per type\n  for(let securityProblem of securityProblems) {\n    let vulnerabilityTypeIndex = vulnerabilityTypeStats.records.findIndex(el => el.vulnerabilityType === securityProblem.vulnerabilityType);\n    if(vulnerabilityTypeIndex > -1) {\n      vulnerabilityTypeStats.records[vulnerabilityTypeIndex].count++;\n    } else {\n      vulnerabilityTypeStats.records.push({\n        vulnerabilityType: securityProblem.vulnerabilityType,\n        count: 1\n      })\n    }\n  }\n  return vulnerabilityTypeStats;\n}","visualization":"categoricalBarChart","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"process groups","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"72":{"type":"code","title":"","input":"import { monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"serviceKeyRequests\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SERVICE_METHOD\"),fromRelationships.isServiceMethodOfService(type(\"SERVICE\"))';\n    } else {\n      entitySelector = `type(\"SERVICE_METHOD\"),fromRelationships.isServiceMethodOfService(type(\"SERVICE\")),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all Key user actions\n    let objects = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all monitored Web apps\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all mobile apps\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all custom apps\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    // All apps\n    const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n    // Compute the ratio between the number of Key user actions and apps\n    const serviceKeyRequestRatio = objects.totalCount / monitoredApps;\n    // Compute local score based on above ratio\n    const score = (serviceKeyRequestRatio >= 3) ? 1 : (serviceKeyRequestRatio >= 1 ? 0.5 : 0);\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${objects.totalCount}`;\n        break;\n      case score === 0.5:\n        result = `üí° ${objects.totalCount}`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è ${objects.totalCount}`;\n        break;\n    }\n    // Return the emojied result\n    return result;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Service key requests","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"73":{"type":"code","title":"","input":"import { metricsClient, monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"calculatedServiceMetrics\")) {\n    if($Scope[0] === \"Tenant\") {\n      // Get all monitored apps\n      let config = { acceptType: \"application/json; charset=utf-8\", text: \"calc:service\" };\n      let objects = await metricsClient.allMetrics(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n      const webApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n      const mobileApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n      const customApps = await monitoredEntitiesClient.getEntities(config);\n      const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n      // Compute ratio between user session metrics and monitored apps\n      const csmRatio = objects.totalCount / monitoredApps;\n      // Compute local score based on above ratio\n      const score = csmRatio >= 3 ? 1 : (csmRatio >= 1 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${objects.totalCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${objects.totalCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${objects.totalCount}`;\n          break;\n      }\n      // Return the emojied result\n      return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Calculated service metrics","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"74":{"type":"code","title":"","input":"import { metricsClient, monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"uscm\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { acceptType: \"application/json; charset=utf-8\", text: \"uscm.\" };\n      // Get all user session custom metrics\n      let objects = await metricsClient.allMetrics(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n      const webApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n      const mobileApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n      const customApps = await monitoredEntitiesClient.getEntities(config);\n      // Count all monitored apps\n      const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n      // Compute the ratio between USCMs and monitored apps\n      const uscmRatio = objects.totalCount / monitoredApps;\n      // Compute local score based on above ratio\n      const score = uscmRatio >= 3 ? 1 : (uscmRatio >= 1 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${objects.totalCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${objects.totalCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${objects.totalCount}`;\n          break;\n      }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"User session custom metrics","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"75":{"type":"markdown","title":"","content":"Each [alerting profile](https://www.dynatrace.com/support/help/observe-and-explore/notifications-and-alerting/alerting-profiles) defines the list of conditions that need to be checked before triggering the sending of a problem notification.\n\nAssigning an alerting profile to [a specific management zone](https://www.dynatrace.com/support/help/observe-and-explore/notifications-and-alerting/alerting-profiles#expand--management-zone-filtering) permits alerting teammates on incidents that really matter to them, and reduce alert spam.\n\n[Problem notifications](https://www.dynatrace.com/support/help/observe-and-explore/notifications-and-alerting/problem-notifications) define how and who to send a notification to once triggered by the associated alerting profile.\n\nIt's recommended to use diverse types of notification pipelines (eg. Slack, Teams, Jira, PagerDuty, email,...) depending on the problem scope, criticity and responsible teams.\n\n[Metric events](https://www.dynatrace.com/support/help/observe-and-explore/davis-ai/anomaly-detection/metric-events) raise problems and alert when the threshold you define is breached for a certain metric (eg. alert above 80% CPU usage for a subset of hosts). They help complementing native anomaly detection with custom alerts tailored to your use-case."},"76":{"type":"markdown","title":"","content":"Service Level Objectives ensure the prioritization and real-time monitoring of the most business-critical services your apps provide.\n\nLet your SRE teams [define and track most relevant SLOs](https://www.dynatrace.com/support/help/platform-modules/cloud-automation/service-level-objectives/slo-basics) for each application.\n\nIt's recommended to [create metric events](https://www.dynatrace.com/support/help/platform-modules/cloud-automation/service-level-objectives/configure-and-monitor-slo#alerts) to alert on fast error budget burn rates and when remaining error budgets get close to breaching a target threshold. Dynatrace does not automatically raise problems on those two use cases.\n\nIntegrating your [issue-tracking system](https://www.dynatrace.com/support/help/platform-modules/cloud-automation/release-monitoring/issue-tracking-integration) with Dynatrace helps get statistics about release issues for your monitored entities and configure dynamic queries."},"77":{"type":"markdown","title":"","content":"Application Security leverages the unique Dynatrace technologies to empower DevSecOps teams to collaborate in resolving priority security problems throughout your entire app eco-systems.\n\nThe [Runtime Vulnerability Analytics](https://www.dynatrace.com/support/help/platform-modules/application-security/vulnerability-analytics) capability is designed to pinpoint vulnerabilities that need immediate investigation. It automatically analyzes data access paths and production execution to provide an automatic risk and impact assessment.\n\nThe [Runtime Application Protection](https://www.dynatrace.com/support/help/platform-modules/application-security/application-protection) capability leverages code-level insights and transaction analysis to detect and block attacks on your applications automatically and in real time.\n\n"},"78":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"logMonitoring\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { schemaIds: 'builtin:logmonitoring.log-storage-settings'};\n      let objects = { items: [] };\n      try {\n        // Get log monitoring storage settings\n        objects = await settingsObjectsClient.getSettingsObjects(config);  \n      } catch(e) {}\n      // Count active log storage rules\n      const logStorageIncludeRules = objects.items.filter(el => el.value.enabled).length;\n      // Compute local score based on the number of log storage rules\n      const score = logStorageIncludeRules > 0 ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ON`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è OFF`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Log Management and Analytics","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"79":{"type":"markdown","title":"","content":" "},"81":{"type":"markdown","title":"","content":" "},"83":{"type":"markdown","title":"","content":"Log Management and Analytics, powered by Grail‚Ñ¢, provides a unified approach to unlocking the value of log data in the Dynatrace platform at petabyte scale and without schemas, indexing, or rehydration.\n\nThis capability is enabled by default on the tenant and by each OneAgent. However, [bucket inclusion rules](https://www.dynatrace.com/support/help/observe-and-explore/logs/log-management-and-analytics/lma-log-buckets-and-retention) are required to define the scope of the logs you need to ingest, store and analyze.\n\nThe [Dynatrace Query Language (DQL)](https://www.dynatrace.com/support/help/observe-and-explore/query-data/dynatrace-query-language) gives you complete freedom to query, analyze and transform ingested log records in an instant, and without the need to know and set up processing rules before-hand.\n\nCreate [log events](https://www.dynatrace.com/support/help/observe-and-explore/logs/log-management-and-analytics/lma-analysis/lma-log-events) to receive real-time alerts when a specific pattern gets detected in new log records."},"84":{"type":"code","title":"","input":"import { documentsClient } from '@dynatrace-sdk/client-document';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"dashboards\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { filter: \"type = 'dashboard'\"};\n      // Get all Dashboards from active user\n      let objects = await documentsClient.listDocuments(config);\n      // Compute local score based on the number of Dashboards from active user\n      const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 5 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${objects.totalCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${objects.totalCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${objects.totalCount}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"(New) Dashboards (my user)","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"85":{"type":"code","title":"","input":"import { documentsClient } from '@dynatrace-sdk/client-document';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"notebooks\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { filter: \"type = 'notebook'\"};\n      // Get all Notebooks from active user\n      let objects = await documentsClient.listDocuments(config);\n      // Compute local score based on the number of Notebooks from active user\n      const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 5 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${objects.totalCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${objects.totalCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${objects.totalCount}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Notebooks (my user)","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"86":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"networkZones\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { schemaIds: 'builtin:networkzones'};\n      // Get network zones\n      const objects = await settingsObjectsClient.getSettingsObjects(config);\n      // Compute local score based on the number of network zones\n      const score = objects.totalCount > 0 ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${objects.totalCount}`;\n          break;\n        case score === 0:\n          result = `üí° ${objects.totalCount}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Network zones","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"87":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"auditLogs\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { schemaIds: 'builtin:audit-log'};\n      let objects;\n      try {\n        // Get audit log settings\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Check if it's enabled and compute local score accordingly\n      const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enabled ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ON`;\n          break;\n        case score === 0:\n          result = `üí° OFF`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Audit logs","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"88":{"type":"code","title":"","input":"import { monitoredEntitiesMonitoringStateClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"uniqueServices\") || $Indicators.includes(\"customServices\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"PROCESS_GROUP_INSTANCE\")';\n    } else {\n      entitySelector = `type(\"PROCESS_GROUP_INSTANCE\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector, pageSize: 12000 };\n    // Get all process group instance monitoring states\n    const objects = await monitoredEntitiesMonitoringStateClient.getStates(config);\n    const deepMonitoringEvents = objects.monitoringStates.map(el => {\n      const filteredEntry = {};\n      filteredEntry[\"Deep monitoring event\"] = el.severity === \"warning\" ? `‚ö†Ô∏è ${el.state}` : el.state;\n      filteredEntry[\"entityId\"] = el.entityId;\n      return filteredEntry;\n    });\n    // Return the emojied result\n    return deepMonitoringEvents.filter(el => el[\"Deep monitoring event\"] !== \"ok\").length > 0 ? deepMonitoringEvents.filter(el => el[\"Deep monitoring event\"] !== \"ok\") : { \"Deep monitoring event\": \"‚ö†Ô∏è No deep monitoring event detected\"};\n  } else {\n    return { \"Deep monitoring event\": \"N/A\"};\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"oldest supported OneAgent","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"89":{"type":"code","title":"","input":"export default async function() {\n  const oldestSupportedVersion = `1.${Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18}`;\n  return oldestSupportedVersion;\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Oldest supported OneAgent","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"90":{"type":"code","title":"API calls to ActiveGates from the last 7 days","input":"import { metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"accessTokens\")) {\n    if($Scope[0] === \"Tenant\") {\n      // For each app, determine if there's any conversion rate captured in the last 7 days\n      let config = { from: \"now-7d\", acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:active_gate.rest.request_count:splitBy(operation):sort(value(auto,descending)):limit(5):fold(value)'};\n      let objects = await metricsClient.query(config);\n      // Prepare template for graph visualization\n      const apiStats = {\n        records: [],\n        types: [\n          {\n            mappings: {\n              api: {\n                type: \"string\"\n              },\n              calls: {\n                type: \"long\"\n              }\n            },\n            indexRange: [\n              0,\n              1\n            ]\n          }\n        ]\n      };\n      // Get calls count for each API endpoint\n      for(let api of objects.result[0].data) {\n        let apiStatsIndex = apiStats.records.findIndex(el => el.api === api.dimensionMap.operation);\n        apiStats.records.push({\n          api: api.dimensionMap.operation,\n          calls: api.values[0]\n        })\n      }\n      return apiStats;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"categoricalBarChart","visualizationSettings":{"chartSettings":{"gapPolicy":"connect","categoricalBarChartSettings":{"layout":"vertical","categoryAxis":"api","categoryAxisLabel":"api","valueAxis":"calls","valueAxisLabel":"calls"}},"singleValue":{"showLabel":true,"label":"","autoscale":true},"table":{"enableLineWrap":false,"lineWrapIds":[]}}},"92":{"type":"code","title":"","input":"import { metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"oneAgentVersions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n      const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n      let config = { from: \"now-5m\", acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:cluster.oneagent.agent_modules:filter(and(or(eq(\"dt.oneagent.agent_type\",os)))):splitBy(\"dt.oneagent.version\"):sum:last():sort(value(sum,descending)):limit(100)'};\n      // Get OneAgents count per version\n      let objects = await metricsClient.query(config);\n      const oneAgentVersionStats = [];\n      // Prepare data for displaying the count of OneAgents per version and emoji corresponding to their age category\n      for(let oneAgentVersion of objects.result[0].data) {\n        const score = oneAgentVersion.dimensionMap['dt.oneagent.version'].substring(2) >= (latestVersion - 6) ? 1 : (oneAgentVersion.dimensionMap['dt.oneagent.version'].substring(2) >= oldestSupportedVersion ? 0.5 : 0);\n        let result = {};\n        switch(true) {\n          case score === 1:\n            result['OneAgent Version'] = `‚úÖ ${oneAgentVersion.dimensionMap['dt.oneagent.version']}`;\n            break;\n          case score === 0.5:\n            result['OneAgent Version'] = `üí° ${oneAgentVersion.dimensionMap['dt.oneagent.version']}`;\n            break;\n          case score === 0:\n            result['OneAgent Version'] = `‚ö†Ô∏è ${oneAgentVersion.dimensionMap['dt.oneagent.version']}`;\n            break;\n        }\n        result.Running = oneAgentVersion.values[0];\n        oneAgentVersionStats.push(result);\n      }\n      return oneAgentVersionStats;\n    } else {\n      return {\n        \"OneAgent Version\": `N/A`\n      };\n    }\n  } else {\n    return {\n      \"OneAgent Version\": `N/A`\n    };\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect","categoricalBarChartSettings":{"layout":"horizontal"}},"singleValue":{"showLabel":true,"label":"audit logs","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"93":{"type":"code","title":"","input":"import { metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"extensions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_count:last(avg)'};\n      // Get the number of extensions deployed\n      const objects = await metricsClient.query(config);\n      const extensionCount = objects.result[0].data[0].values[0];\n      // Compute local score based on above number\n      const score = extensionCount >= 10 ? 1 : (extensionCount > 0 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${extensionCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${extensionCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${extensionCount}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Extensions","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"94":{"type":"code","title":"","input":"import { metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"extensionConfigurations\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_monitoring_configuration_count:last(avg)'};\n      // Get the number of extension configurations\n      let objects = await metricsClient.query(config);\n      const extensionConfigCount = objects.result[0].data[0].values[0];\n      config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_count:last(avg)'};\n      // Get the number of extensions deployed\n      objects = await metricsClient.query(config);\n      const extensionCount = objects.result[0].data[0].values[0];\n      // Compute the ratio between extension configurations and extensions, and its corresponding local score\n      const score = extensionConfigCount >= extensionCount * 1.5 ? 1 : (extensionConfigCount >= extensionCount ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${extensionConfigCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${extensionConfigCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${extensionConfigCount}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Ext. configurations","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"95":{"type":"code","title":"","input":"import { metricsClient, monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\n// Helper function to filter duplicates\nfunction onlyUnique(value, index, array) {\n  return array.indexOf(value) === index;\n}\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"cloudIntegrations\")) {\n    if($Scope[0] === \"Tenant\") {\n      // Count cloud integrations\n      let config = { writtenSince: \"now-1d\", acceptType: \"application/json; charset=utf-8\", text: \"builtin:cloud\", pageSize: 500 };\n      let objects = await metricsClient.allMetrics(config);\n      let metrics = objects.metrics;\n      while(objects.nextPageKey) {\n        config = { acceptType: \"application/json; charset=utf-8\", nextPageKey: objects.nextPageKey };\n        objects = await metricsClient.allMetrics(config);\n        metrics = [...metrics, ...objects.metrics];\n      }\n      let cloudIntegrationCount = metrics.map(el => el.metricId.substring(\"builtin:cloud.\".length,(\"builtin:cloud.\".length + el.metricId.substring(\"builtin:cloud.\".length).indexOf(\".\")))).filter(onlyUnique).length;\n      // Count Kubernetes integrations\n      config = { from: \"now-1d\", entitySelector: `type(\"KUBERNETES_CLUSTER\")` };\n      objects = await monitoredEntitiesClient.getEntities(config);\n      if(objects.totalCount) cloudIntegrationCount++;\n      // Compute local score based on the number of cloud integrations configured\n      const score = cloudIntegrationCount >= 3 ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${cloudIntegrationCount}`;\n          break;\n        case score === 0:\n          result = `üí° ${cloudIntegrationCount}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Cloud integrations","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"96":{"type":"code","title":"","input":"import { activeGatesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"activeGateVersions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n      const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n      const objects = await activeGatesClient.getAllActiveGates();\n      const activeGates = objects.activeGates.map(el => {\n        const filteredEntry = {};\n        switch(true) {\n        case parseInt(el.version.substring(2,5)) < oldestSupportedVersion:\n          filteredEntry.Version = `‚ö†Ô∏è ${el.version}`;\n          break;\n        case parseInt(el.version.substring(2,5)) < (latestVersion - 6):\n          filteredEntry.Version = `üí° ${el.version}`;\n          break;\n        default:\n          filteredEntry.Version = `‚úÖ ${el.version}`;\n        }\n        filteredEntry.ActiveGate = el.hostname;\n        return filteredEntry;\n      });\n    \n      return activeGates.sort(function (a, b) {\n        if (a.Version.substr(4, 3) > b.Version.substr(4, 3)) {\n          return 1;\n        }\n        if (a.Version.substr(4, 3) < b.Version.substr(4, 3)) {\n          return -1;\n        }\n        return 0;\n      });\n    } else {\n      return {\n        \"ActiveGate\": `N/A`\n      };\n    }\n  } else {\n    return {\n      \"ActiveGate\": `N/A`\n    };\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"oldest supported OneAgent","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"98":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"managementZones\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")', fields: 'managementZones', pageSize: 500};\n      // Get all apps and their management zones\n      const objects = await monitoredEntitiesClient.getEntities(config);\n      // Filter apps with no management zone\n      let appsWithNoMz = objects.entities.filter(el => el.managementZones.length === 0);\n      // Format data for table visualization\n      appsWithNoMz = appsWithNoMz.map(el => {\n        return {\n          \"App with no management zone\": `‚ö†Ô∏è ${el.displayName}`,\n          entityId: el.entityId\n        };\n      })\n      // Return list\n      return appsWithNoMz.length > 0 ? appsWithNoMz : { \"App with no management zone\": \"‚úÖ All apps are included in a specific MZ\"};\n    } else {\n      return {\n        \"App with no management zone\": `N/A`\n      };\n    }\n  } else {\n    return {\n      \"App with no management zone\": `N/A`\n    };\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"host group coverage","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["Hosts with no host group:"]]}}},"100":{"type":"code","title":"","input":"import { settingsObjectsClient, monitoredEntitiesClient, monitoredEntitiesCustomTagsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nasync function getUntaggedEntities(entityType, tags) {\n  // Retrieve the scope\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = `type(\"${entityType}\"),not(tag(\"${tags.join('\",\"')}\"))`;\n  } else {\n    entitySelector = `type(\"${entityType}\"),not(tag(\"${tags.join('\",\"')}\")),mzName(${scope})`;\n  }\n  const config = { from: \"now-7d\", entitySelector: entitySelector, pageSize: 500};\n  let objects = [];\n  try {\n    // Get all untagged entities\n    objects = await monitoredEntitiesClient.getEntities(config);\n    objects = objects.entities.map(el => {\n    return {\n      \"Untagged entity\": `üí° ${el.displayName}`,\n      entityId: el.entityId\n    };\n  });\n  } catch(e) {}\n  return objects;\n}\n\nasync function getAllUntaggedEntities(entityTypes, autoTags) {\n  let allUntaggedEntities = [];\n  for(let entityType of entityTypes) {\n    let customTags = await monitoredEntitiesCustomTagsClient.getTags({ entitySelector: `type(\"${entityType}\")` });\n    customTags = customTags.tags.map(el => el.key);\n    const allTags = [...autoTags, ...customTags];\n    const untaggedEntities = await getUntaggedEntities(entityType, allTags);\n    allUntaggedEntities = [...allUntaggedEntities, ...untaggedEntities];\n  }\n  return allUntaggedEntities;\n}\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"autoTags\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:tags.auto-tagging'};\n      // Get all auto tags\n      let objects = await settingsObjectsClient.getSettingsObjects(config);\n      const autoTags = objects.items.map(el => el.value.name);\n      let entityTypes = ['SYNTHETIC_TEST', 'APPLICATION', 'MOBILE_APPLICATION', 'CUSTOM_APPLICATION', 'SERVICE', 'PROCESS_GROUP', 'HOST'];\n      const allUntaggedEntities = await getAllUntaggedEntities(entityTypes, autoTags);\n      // Return list of untagged entities\n      return allUntaggedEntities.length > 0 ? allUntaggedEntities : { \"Untagged entity\": \"‚úÖ No untagged entity detected\"};\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"management zones","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"101":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"workflows\")) {\n    if($Scope[0] === \"Tenant\") {\n      /*\n      const config = { filter: \"type = 'notebook'\"};\n      // Get all Workflows from active user\n      let objects = await workflowsClient.getWorkflows(config);\n      // Compute local score based on the number of Notebooks from active user\n      let result;\n      switch(true) {\n        case objects.totalCount < 3:\n          result = `‚ö†Ô∏è ${objects.totalCount}`;\n          break;\n        case objects.totalCount < 10:\n          result = `üí° ${objects.totalCount}`;\n          break;\n        default:\n          result = `‚úÖ ${objects.totalCount}`;\n      }*/\n      return \"Soon...\";\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Workflows (my user)","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"102":{"type":"code","title":"","input":"import { monitoredEntitiesCustomTagsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"manualTags\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    let allCustomTags = [];\n    // Define list of entities to get manual tags for\n    let entityTypes = ['SYNTHETIC_TEST', 'APPLICATION', 'MOBILE_APPLICATION', 'CUSTOM_APPLICATION', 'SERVICE', 'PROCESS_GROUP', 'HOST'];\n    // For entity type, retrieve the list of manual tags\n    for(let entityType of entityTypes) {\n      let entitySelector;\n      if(scope === \"Tenant\") {\n        entitySelector = `type(\"${entityType}\")`;\n      } else {\n        entitySelector = `type(\"${entityType}\"),mzName(${scope})`;\n      }\n      let customTags = await monitoredEntitiesCustomTagsClient.getTags({ entitySelector: entitySelector });\n      customTags = customTags.tags.map(el => el.key);\n      allCustomTags = [...allCustomTags, ...customTags];\n    }\n    // Compute local score based on the number of manual tags\n    if(scope === \"Tenant\") {\n      const score = allCustomTags.length < 50 ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${allCustomTags.length}`;\n          break;\n        case score === 0:\n          result = `üí° ${allCustomTags.length}`;\n          break;\n      }\n     // Return the emojied result\n     return result;\n    } else {\n      return allCustomTags.length;\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Manual tags","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"103":{"type":"code","title":"","input":"import { monitoredEntitiesCustomTagsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"manualTags\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    let allCustomTags = [];\n    // Define the list of entity types to retrieve manual tags for\n    let entityTypes = ['SYNTHETIC_TEST', 'APPLICATION', 'MOBILE_APPLICATION', 'CUSTOM_APPLICATION', 'SERVICE', 'PROCESS_GROUP', 'HOST'];\n    for(let entityType of entityTypes) {\n      let entitySelector;\n      if(scope === \"Tenant\") {\n        entitySelector = `type(\"${entityType}\")`;\n      } else {\n        entitySelector = `type(\"${entityType}\"),mzName(${scope})`;\n      }\n      // Get manual tags for each entity type\n      let customTags = await monitoredEntitiesCustomTagsClient.getTags({ entitySelector: entitySelector });\n      customTags = customTags.tags.map(el => {\n        return { \"Manual tag\": el.key};\n        });\n      allCustomTags = [...allCustomTags, ...customTags];\n    }\n    // Return list\n    return allCustomTags.length > 0 ? allCustomTags : { \"Manual tag\": \"No manual tag detected\"};\n  } else {\n    return { \"Manual tag\": \"N/A\"};\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"management zones","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"104":{"type":"markdown","title":"","content":" "},"105":{"type":"code","title":"","input":"import { accessTokensApiTokensClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"accessTokens\")) {\n    if($Scope[0] === \"Tenant\") {\n      /*\n      // For each app, determine if there's any conversion rate captured in the last 7 days\n      let config = { apiTokenSelector: \"personalAccessToken(false)\"};\n      let objects = await accessTokensApiTokensClient.listApiTokens(config);\n      return objects;\n      */\n      return \"Soon...\";\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"API tokens","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"106":{"type":"markdown","title":"","content":" "},"107":{"type":"code","title":"","input":"export default async function() {\n  const oldestSupportedVersion = `1.${Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18}`;\n  return oldestSupportedVersion;\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Oldest supported ActiveGate","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"109":{"type":"markdown","title":"","content":" "},"110":{"type":"markdown","title":"","content":"Dynatrace APIs requires token-based authentication before returning expected data from a tenant.\n\n[Access Tokens](https://www.dynatrace.com/support/help/manage/access-control/access-tokens) are created and managed by all admins. They are given a specific set of permissions that are scoped to the entire tenant.\n\n[Personal Access Tokens (PAT)](https://www.dynatrace.com/support/help/manage/access-control/access-tokens/personal-access-token) are tied to specified Dynatrace users and restricted to their management-zone-level permissions."},"111":{"type":"markdown","title":"","content":"Keeping the OneAgent running with the most recent versions brings you its latest features, performance and security benefits to stay at the forefront of observability.\n\nEach OneAgent version is [supported](https://www.dynatrace.com/company/trust-center/support-slas/) for 9 months, or 12 months through a Dynatrace ONE Premium subscription.\n\nJoin the [Deployment status page](https://hwz97639.sprint.apps.dynatracelabs.com/ui/apps/dynatrace.classic.deployment.status/ui/deploymentstatus/oneagents?gtf=-2h&gf=all&recentlyConnected=false&timeframeDs=LAST_3_DAY&filters=MONITORED_HOST-INSTALLER_VERSION_LE%3A1.251) and filter unsupported OneAgents by their running version.\n\nGet to know the features and OS/technology support changes brought by each new version in the [Release Notes](https://www.dynatrace.com/support/help/whats-new/release-notes/oneagent).\n\nStay ahead and regularly check the announcements for upcoming [end-of-support](https://www.dynatrace.com/support/help/whats-new/end-of-support-news) events."},"112":{"type":"markdown","title":"","content":"Keep the ActiveGates updated elevates your capacity for remote monitoring, synthetic testing, manage your observability data flows, increase your security posture and much more.\n\nEach ActiveGate version is [supported](https://www.dynatrace.com/company/trust-center/support-slas/) for 9 months, or 12 months through a Dynatrace ONE Premium subscription.\n\nGet to know the features and OS/technology support changes brought by each new version in the [Release Notes](https://www.dynatrace.com/support/help/whats-new/release-notes/activegate).\n\nStay ahead and regularly check the announcements for upcoming [end-of-support](https://www.dynatrace.com/support/help/whats-new/end-of-support-news#tabgroup--news--dynatrace-activegate) events."},"113":{"type":"code","title":"","input":"export default async function() {\n  const oldestSupportedVersion = `1.${Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2}`;\n  return oldestSupportedVersion;\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Latest OneAgent version","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"114":{"type":"code","title":"","input":"export default async function() {\n  const oldestSupportedVersion = `1.${Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2}`;\n  return oldestSupportedVersion;\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Latest ActiveGate version","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"115":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"osServices\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:os-services-monitoring'};\n      // Get all OS service monitoring rules\n      const objects = await settingsObjectsClient.getSettingsObjects(config);\n      const osServicesAlertingRules = objects.items.filter(el => el.value.enabled);\n      // Compute local score based on OS service monitoring rules\n      const score = osServicesAlertingRules.length > 1 ? 1 : (osServicesAlertingRules.length === 1 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${osServicesAlertingRules.length}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${osServicesAlertingRules.length}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${osServicesAlertingRules.length}`;\n          break;\n      }\n      // Return the emojied result\n      return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"OS services alerting rules","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"116":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"ownershipTeams\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:ownership.teams'};\n      // Get ownership teams configured\n      const objects = await settingsObjectsClient.getSettingsObjects(config);\n      // Compute local score based on the number of ownership teams configured\n      const score = objects.items.length >= 10 ? 1 : (objects.items.length >= 5 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${objects.items.length}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${objects.items.length}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${objects.items.length}`;\n          break;\n        }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Ownership teams","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"117":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"uniqueProcessGroups\") || $Indicators.includes(\"declarativeProcessGroupings\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"PROCESS_GROUP\")';\n    } else {\n      entitySelector = `type(\"PROCESS_GROUP\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector, sort: \"name\", pageSize: 12000 };\n    // Get all process groups\n    let objects = await monitoredEntitiesClient.getEntities(config);\n    // Format table entries\n    let processGroups = objects.entities.map(el => {\n      return {\n        \"Process group\": el.displayName,\n        \"Duplicate\": `‚úÖ NO`,\n        entityId: el.entityId\n      };\n    });\n    // Loop through pagination\n    while(objects.nextPageKey) {\n      config = { nextPageKey: objects.nextPageKey };\n      objects = await monitoredEntitiesClient.getEntities(config);\n      const otherProcessGroups = objects.entities.map(el => {\n        return {\n          \"Process group\": el.displayName,\n          \"Duplicate\": `‚úÖ NO`,\n          entityId: el.entityId\n        };\n      });\n      processGroups = [...processGroups, ...otherProcessGroups];\n    }\n    // Helper function to filter duplicates\n    const lookup = processGroups.reduce((a, e) => {\n      a[e[\"Process group\"]] = ++a[e[\"Process group\"]] || 0;\n      return a;\n    }, {});\n    let duplicateProcessGroups = [];\n    let uniqueProcessGroups = [];\n    for(let processGroup of processGroups) {\n      if(lookup[processGroup[\"Process group\"]]) {\n        processGroup[\"Duplicate\"] = `‚ö†Ô∏è YES`;\n        duplicateProcessGroups.push(processGroup);\n      } else {\n        uniqueProcessGroups.push(processGroup);\n      }\n    }\n    // List duplicate process groups first, unique ones second\n    const allProcessGroups = [...duplicateProcessGroups, ...uniqueProcessGroups];\n    // Return list\n    return allProcessGroups.length > 0 ? allProcessGroups.slice(0, 500) : { \"Process group\": \"‚ö†Ô∏è No process group detected\"};\n  } else {\n    return { \"Process group\": \"N/A\"};\n  }\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"process groups","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"118":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"uniqueProcessGroups\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"PROCESS_GROUP\")';\n    } else {\n      entitySelector = `type(\"PROCESS_GROUP\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector, pageSize: 12000 };\n    // Get all process groups by looping through the pagination\n    let objects = await monitoredEntitiesClient.getEntities(config);\n    const processGroupsCount = objects.totalCount;\n    let processGroups = objects.entities;\n    while(objects.nextPageKey) {\n      config = { nextPageKey: objects.nextPageKey };\n      objects = await monitoredEntitiesClient.getEntities(config);\n      processGroups = [...processGroups, ...objects.entities];\n    }\n    // Helper function for filtering duplicates\n    const lookup = processGroups.reduce((a, e) => {\n      a[e.displayName] = ++a[e.displayName] || 0;\n      return a;\n    }, {});\n    // Get duplicates\n    const duplicates = processGroups.filter(e => lookup[e.displayName]);\n    // Compute the ratio of unique process names\n    const uniqueProcessGroupRatio = 100 - parseInt(duplicates.length / processGroupsCount * 100);\n    // Compute local score based on the ratio of unique process names\n    const score = uniqueProcessGroupRatio === 100 ? 1 : (uniqueProcessGroupRatio >= 95 ? 0.5 : 0);\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${uniqueProcessGroupRatio}%`;\n        break;\n      case score === 0.5:\n        result = `üí° ${uniqueProcessGroupRatio}%`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è ${uniqueProcessGroupRatio}%`;\n        break;\n    }\n    // Return the emojied result\n    return result;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Unique process groups","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"119":{"type":"code","title":"","input":"import { metricsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"logMonitoring\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { from: \"now-7d\", acceptType: \"application/json; charset=utf-8\", metricSelector: \"builtin:billing.log.ingest.usage\", resolution: \"1d\" };\n      // Get log ingest usage metric\n      const objects = await metricsClient.query(config);\n      const date = new Date();\n      date.setTime(date.getTime() + 86400000);\n      const end = `${date.toISOString().substring(0, 10)}T00:00:00.000Z`;\n      date.setTime(date.getTime() - 8 * 86400000);\n      const start = `${date.toISOString().substring(0, 10)}T00:00:00.000Z`;\n      // Format the data for graph visualization\n      const timeseries = {\n        \"records\": [\n          {\n            \"Daily log ingest\": objects.result[0].data[0].values,\n            \"timeframe\": {\n              \"start\": start,\n              \"end\": end\n            },\n            \"interval\": \"86400000000000\"\n          }\n        ],\n        \"metadata\": {\n          \"metrics\": [\n            {\n              \"metric.key\": \"builtin:billing.log.ingest.usage\",\n              \"displayName\": \"Log ingest\",\n              \"description\": \"\",\n              \"unit\": \"Byte\"\n            }\n          ]\n        },\n        \"types\": [\n          {\n            \"mappings\": {\n              \"Daily log ingest\": {\n                \"type\": \"array\",\n                \"types\": [\n                  {\n                    \"mappings\": {\n                      \"element\": {\n                        \"type\": \"double\"\n                      }\n                    },\n                    \"indexRange\": [\n                      0,\n                      7\n                    ]\n                  }\n                ]\n              },\n              \"timeframe\": {\n                \"type\": \"timeframe\"\n              },\n              \"interval\": {\n                \"type\": \"duration\"\n              }\n            },\n            \"indexRange\": [\n              0,\n              0\n            ]\n          }\n        ]\n      };\n      return timeseries;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"barChart","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Ingested (last 24h)","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"121":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"fullStackCoverage\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST\"),monitoringMode(\"FULL_STACK\")';\n    } else {\n      entitySelector = `type(\"HOST\"),monitoringMode(\"FULL_STACK\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all Full Stack monitored hosts\n    const fullStackHosts = await monitoredEntitiesClient.getEntities(config);\n    // Define entity selector based on the selected scope\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false)';\n    } else {\n      entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),mzName(${scope})`;\n    }\n    config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all monitored hosts\n    const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n    // Compute Full Stack coverage percentage\n    const fullStackCoverage = Math.round(fullStackHosts.totalCount/monitoredHosts.totalCount*100);\n    // Compute local score based on the Full Stack coverage\n    const score = fullStackCoverage === 100 ? 1 : (fullStackCoverage >= 80 ? 0.5 : 0);\n    // Define the dynamic recommendation based on the local score\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ All hosts benefit from Full Stack monitoring`;\n        break;\n      case score === 0.5:\n        result = `üí° Regularly check if you could maximize the coverage of Full Stack monitoring`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è Make sure you enable Full Stack monitoring on all hosts running code`;\n        break;\n    }\n    // Return the emojied recommendation\n    return result;\n  } else {\n    return `Select the \"fullStackCoverage\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"122":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"candidates\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { from: `now-1d`, entitySelector: 'type(\"HOST\"),isMonitoringCandidate(false)'};\n      // Get all monitored hosts\n      const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n      config = { from: `now-1d`, entitySelector: 'type(\"HOST\"),isMonitoringCandidate(true)'};\n      // Get all monitoring candidates\n      const monitoringCandidates = await monitoredEntitiesClient.getEntities(config);\n      // Compute local score based on the relative number of candidates\n      const score = monitoringCandidates.totalCount === 0 ? 1 : (monitoringCandidates.totalCount < 50 ? 0.5 : 0);\n      // Define the dynamic recommendation based on the local score\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ All discovered candidates are now monitored`;\n          break;\n        case score === 0.5:\n          result = `üí° Deploy the OneAgent on the remaining monitoring candidates`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Deploy the OneAgent on the many monitoring candidates discovered by Dynatrace`;\n          break;\n      }\n      // Return the emojied recommendation\n      return result;\n    } else {\n      return `Select the \"Tenant\" scope to review monitoring candidates`;\n    }\n  } else {\n    return `Select the \"candidates\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"123":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"hostGroups\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST_GROUP\")';\n    } else {\n      entitySelector = `type(\"HOST_GROUP\"),toRelationships.isInstanceOf(type(\"HOST\"),mzName(${scope}))`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all host groups\n    const hostGroups = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all Web apps\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all mobile apps\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all custom apps\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    // Compute ratio between the number of host groups and monitored apps\n    const hostGroupAppRatio = hostGroups.totalCount/(webApps.totalCount + mobileApps.totalCount + customApps.totalCount);\n    // Compute local score based on above ratio\n    const score = hostGroupAppRatio >= 1 ? 1 : (hostGroupAppRatio >= 0.8 ? 0.5 : 0);\n    // Define the dynamic recommendation based on the local score\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ There's more host groups than monitored apps`;\n        break;\n      case score === 0.5:\n        result = `üí° Assign a host group to all the servers running each monitored app`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è Assign a host group to all the servers running each monitored app`;\n        break;\n    }\n    // Return the emojied recommendation\n    return result;\n  } else {\n    return `Select the \"hostGroups\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"124":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"hostGroupCoverage\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false)';\n    } else {\n      entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),mzName(${scope})`;\n    }\n    let config = { from: `now-1d`, entitySelector: entitySelector};\n    // Get all monitored hosts\n    const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false),fromRelationships.isInstanceOf(type(\"HOST_GROUP\"))';\n    } else {\n      entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),fromRelationships.isInstanceOf(type(\"HOST_GROUP\")),mzName(${scope})`;\n    }\n    config = { from: `now-1d`, entitySelector: entitySelector};\n    // Get all hosts with host groups\n    const hostsWithHostGroup = await monitoredEntitiesClient.getEntities(config);\n    // Compute host group coverage\n    const hostGroupCoverage = Math.round(hostsWithHostGroup.totalCount/monitoredHosts.totalCount*100);\n    // Compute local score based on the host group coverage\n    const score = hostGroupCoverage === 100 ? 1 : (hostGroupCoverage >= 80 ? 0.5 : 0);\n    // Define the dynamic recommendation based on the local score\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ All monitored hosts are assigned a group`;\n        break;\n      case score === 0.5:\n        result = `üí° Assign a group to all remaining hosts (eg. 'myapp-staging')`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è Make sure you assign a group to each monitored host (eg. 'myapp-staging')`;\n        break;\n    }\n    // Return the emojied recommendation\n    return result;\n  } else {\n    return `Select the \"hostGroupCoverage\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"125":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"uniqueProcessGroups\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"PROCESS_GROUP\")';\n    } else {\n      entitySelector = `type(\"PROCESS_GROUP\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector, pageSize: 12000 };\n    // Get all process groups\n    let objects = await monitoredEntitiesClient.getEntities(config);\n    const processGroupsCount = objects.totalCount;\n    let processGroups = objects.entities;\n    while(objects.nextPageKey) {\n      config = { nextPageKey: objects.nextPageKey };\n      objects = await monitoredEntitiesClient.getEntities(config);\n      processGroups = [...processGroups, ...objects.entities];\n    }\n    // Helper function to filter duplicates\n    const lookup = processGroups.reduce((a, e) => {\n      a[e.displayName] = ++a[e.displayName] || 0;\n      return a;\n    }, {});\n    // Get duplicate process groups\n    const duplicates = processGroups.filter(e => lookup[e.displayName]);\n    // Compute ratio of unique process groups\n    const uniqueProcessGroupRatio = 100 - parseInt(duplicates.length / processGroupsCount * 100);\n    // Compute local score based above ratio\n    const score = uniqueProcessGroupRatio === 100 ? 1 : (uniqueProcessGroupRatio >= 95 ? 0.5 : 0);\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ All monitored process groups have a unique name`;\n        break;\n      case score === 0.5:\n        result = `üí° Define process group naming rules to have each process group monitored under a unique name`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è Define process group naming rules to have each process group monitored under a unique name`;\n        break;\n    }\n    // Return the emojied result\n    return result;\n  } else {\n    return `Select the \"uniqueProcessGroups\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"126":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"uniqueServices\") || $Indicators.includes(\"customServices\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SERVICE\")';\n    } else {\n      entitySelector = `type(\"SERVICE\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector, pageSize: 12000 };\n    // Get all services\n    let objects = await monitoredEntitiesClient.getEntities(config);\n    const servicesCount = objects.totalCount;\n    let services = objects.entities;\n    // Loop through pagination\n    while(objects.nextPageKey) {\n      config = { nextPageKey: objects.nextPageKey };\n      objects = await monitoredEntitiesClient.getEntities(config);\n      services = [...services, ...objects.entities];\n    }\n    // Helper function for filtering duplicates\n    const lookup = services.reduce((a, e) => {\n      a[e.displayName] = ++a[e.displayName] || 0;\n      return a;\n    }, {});\n    // Get duplicate services\n    const duplicates = services.filter(e => lookup[e.displayName]);\n    // Compute ratio between services with unique name and all services\n    const uniqueServiceRatio = 100 - parseInt(duplicates.length / servicesCount * 100);\n    // Compute local score based on above ratio\n    const score = uniqueServiceRatio === 100 ? 1 : (uniqueServiceRatio >= 95 ? 0.5 : 0);\n    // Define the dynamic recommendation based on the local score\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ All monitored services have a unique name`;\n        break;\n      case score === 0.5:\n        result = `üí° Define service naming rules to have each service monitored under a unique name`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è Define service naming rules to have each service monitored under a unique name`;\n        break;\n    }\n    // Return the emojied recommendation\n    return result;\n  } else {\n    return `Select the \"uniqueServices\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"127":{"type":"code","title":"","input":"import { settingsObjectsClient, monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"declarativeProcessGroupings\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:declarativegrouping'};\n      // Get all declarative grouping rules\n      const declarativeGroupings = await settingsObjectsClient.getSettingsObjects(config);\n      config = { from: `now-1d`, entitySelector: 'type(\"PROCESS_GROUP\")'};\n      // Get all process groups\n      const processGroups = await monitoredEntitiesClient.getEntities(config);\n      // Compute ratio between declarative grouping rules and process groups\n      const declarativeGroupingRatio = declarativeGroupings.totalCount / processGroups.totalCount;\n      const score = declarativeGroupingRatio > 0.0001 ? 1 : 0;\n      // Define the dynamic recommendation based on the local score\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging declarative process grouping`;\n          break;\n        case score === 0:\n          result = `üí° You can define declarative process grouping rules to start monitoring unknown or low-consumption processes`;\n          break;\n      }\n      // Return the emojied recommendation\n      return result;\n    } else {\n      return `Select the \"Tenant\" scope to review declarative process groupings`;\n    }\n  } else {\n    return `Select the \"declarativeProcessGroupings\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"128":{"type":"code","title":"","input":"import { monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"serviceKeyRequests\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SERVICE_METHOD\"),fromRelationships.isServiceMethodOfService(type(\"SERVICE\"))';\n    } else {\n      entitySelector = `type(\"SERVICE_METHOD\"),fromRelationships.isServiceMethodOfService(type(\"SERVICE\")),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all Key user actions\n    let objects = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all monitored Web apps\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all mobile apps\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all custom apps\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    // All apps\n    const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n    // Compute the ratio between the number of Key user actions and apps\n    const serviceKeyRequestRatio = objects.totalCount / monitoredApps;\n    // Compute local score based on above ratio\n    const score = (serviceKeyRequestRatio >= 3) ? 1 : (serviceKeyRequestRatio >= 1 ? 0.5 : 0);\n    // Define the dynamic recommendation based on the local score\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ In average, there's more than 3 service key requests implemented per monitored app`;\n        break;\n      case score === 0.5:\n        result = `üí° Make sure to define important endpoints as Key Requests for more advanced monitoring`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è Make sure to define important endpoints as Key Requests for more advanced monitoring`;\n        break;\n    }\n    // Return the emojied recommendation\n    return result;\n  } else {\n    return `Select the \"serviceKeyRequests\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"129":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"customServices\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SERVICE\")';\n    } else {\n      entitySelector = `type(\"SERVICE\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all services\n    const services = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SERVICE\"),serviceType(\"CUSTOM_SERVICE\")';\n    } else {\n      entitySelector = `type(\"SERVICE\"),serviceType(\"CUSTOM_SERVICE\"),mzName(${scope})`;\n    }\n    config = { from: \"now-1d\", entitySelector: entitySelector};\n    // Get all custom services\n    const customServices = await monitoredEntitiesClient.getEntities(config);\n    // Compute ratio between custom services and all services\n    const customServiceRatio = customServices.totalCount / services.totalCount;\n    // Compute local score based on above ratio\n    const score = customServiceRatio > 0.01 ? 1 : (customServiceRatio >= 0.001 ? 0.5 : 0);\n    // Define the dynamic recommendation based on the local score\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ You're leveraging custom services`;\n        break;\n      case score === 0.5:\n        result = `üí° Define custom services to monitor entry points that Dynatrace couldn't model automatically`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è Define custom services to monitor entry points that Dynatrace couldn't model automatically`;\n        break;\n    }\n    // Return the emojied recommendation\n    return result;\n  } else {\n    return `Select the \"customServices\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"130":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"osServices\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:os-services-monitoring'};\n      // Get all OS service monitoring rules\n      const objects = await settingsObjectsClient.getSettingsObjects(config);\n      const osServicesAlertingRules = objects.items.filter(el => el.value.enabled);\n      // Compute local score based on OS service monitoring rules\n      const score = osServicesAlertingRules.length > 1 ? 1 : (osServicesAlertingRules.length === 1 ? 0.5 : 0);\n      // Define the dynamic recommendation based on the local score\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging OS services alerting rules`;\n          break;\n        case score === 0.5:\n          result = `üí° You should set up OS services alerting rules for more operating systems`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è You should start leveraging OS services alerting rules to know when system services go south`;\n          break;\n      }\n      // Return the emojied recommendation\n      return result;\n    } else {\n      return `Select the \"Tenant\" scope to review OS services alerting rules`;\n    }\n  } else {\n    return `Select the \"osServices\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"131":{"type":"code","title":"","input":"import { metricsClient, monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"calculatedServiceMetrics\")) {\n    if($Scope[0] === \"Tenant\") {\n      // Get all monitored apps\n      let config = { acceptType: \"application/json; charset=utf-8\", text: \"calc:service\" };\n      let objects = await metricsClient.allMetrics(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n      const webApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n      const mobileApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n      const customApps = await monitoredEntitiesClient.getEntities(config);\n      const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n      // Compute ratio between user session metrics and monitored apps\n      const csmRatio = objects.totalCount / monitoredApps;\n      // Compute local score based on above ratio\n      const score = csmRatio >= 3 ? 1 : (csmRatio >= 1 ? 0.5 : 0);\n      // Define the dynamic recommendation based on the local score\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging calculated service metrics`;\n          break;\n        case score === 0.5:\n          result = `üí° Define more calculated service metrics to cover your most important service-centric objectives`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Define more calculated service metrics to cover your most important service-centric objectives`;\n          break;\n      }\n      // Return the emojied recommendation\n      return result;\n    } else {\n      return `Select the \"Tenant\" scope to review calculated service metrics`;\n    }\n  } else {\n    return `Select the \"calculatedServiceMetrics\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"132":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nfunction filterEntry(el) {\n  const filteredEntry = {};\n  filteredEntry[\"Monitored apps:\"] = el.displayName === \"My web application\" ? \"‚ö†Ô∏è My web application ‚ö†Ô∏è\" : el.displayName;\n  return filteredEntry;\n}\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"webApps\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    const config = { from: `now-7d`, entitySelector: entitySelector};\n    const objects = await monitoredEntitiesClient.getEntities(config);\n    const webAppsNames = objects.entities.map(el => filterEntry(el));\n    const score = (webAppsNames.some(el => el[\"Monitored apps:\"] === \"‚ö†Ô∏è My web application ‚ö†Ô∏è\") || webAppsNames.length === 0) ? 0 : 1;\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ All RUM traffic gets assigned to its corresponding and explicitly-defined frontend app`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è No app defined or traffic detected on the catch-all 'My Web Application', make sure to assign it to another RUM app`;\n        break;\n    }\n   // Return the emojied recommendation\n   return result;\n  } else {\n    return `Select the \"webApps\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"133":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"iosApps\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n  let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all Web apps\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all mobile apps\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all custom apps\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    const apps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"IOS\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"IOS\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all iOS apps\n    const iosApps = await monitoredEntitiesClient.getEntities(config);\n    // Compute the ratio between iOS apps and all apps\n    const iosAppRatio = iosApps.totalCount / apps;\n    // Compute local score based on above ratio\n    const score = iosAppRatio >= 0.05 ? 1 : 0;\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ More than 5% of the apps you monitor are running on iOS`;\n        break;\n      case score === 0:\n        result = `üí° Monitor your iOS apps to make sure they provide the best experience`;\n        break;\n    }\n   // Return the emojied recommendation\n   return result;\n  } else {\n    return `Select the \"iosApps\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"134":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"androidApps\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n  let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all Web apps\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all mobile apps\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all custom apps\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    const apps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"ANDROID\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"ANDROID\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get Android apps\n    const androidApps = await monitoredEntitiesClient.getEntities(config);\n    // Compute ratio between Android apps and all apps\n    const androidAppRatio = androidApps.totalCount / apps;\n    // Compute local score based on above ratio\n    const score = androidAppRatio >= 0.05 ? 1 : 0;\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ More than 5% of the apps you monitor are running on Android`;\n        break;\n      case score === 0:\n        result = `üí° Monitor your Android apps to make sure they provide the best experience`;\n        break;\n    }\n   // Return the emojied recommendation\n   return result;\n  } else {\n    return `Select the \"androidApps\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"135":{"type":"code","title":"","input":"import { metricsClient, monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"uscm\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { acceptType: \"application/json; charset=utf-8\", text: \"uscm.\" };\n      // Get all user session custom metrics\n      let objects = await metricsClient.allMetrics(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n      const webApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n      const mobileApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n      const customApps = await monitoredEntitiesClient.getEntities(config);\n      // Count all monitored apps\n      const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n      // Compute the ratio between USCMs and monitored apps\n      const uscmRatio = objects.totalCount / monitoredApps;\n      // Compute local score based on above ratio\n      const score = uscmRatio >= 3 ? 1 : (uscmRatio >= 1 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging user session custom metrics`;\n          break;\n        case score === 0.5:\n          result = `üí° Define more user session custom metrics to cover your most important user-centric objectives`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Define more user session custom metrics to cover your most important user-centric objectives`;\n          break;\n      }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review user session custom metrics`;\n    }\n  } else {\n    return `Select the \"uscm\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"136":{"type":"code","title":"","input":"import { settingsObjectsClient, monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"syntheticMonitors\")) {\n    // List all synthetic monitors\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SYNTHETIC_TEST\")';\n    } else {\n      entitySelector = `type(\"SYNTHETIC_TEST\"),mzName(${scope})`;\n    }\n    let config = { from: `now-7d`, entitySelector: entitySelector};\n    // Get all synthetic monitors\n    const objects = await monitoredEntitiesClient.getEntities(config);\n    // Count monitored apps\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"APPLICATION\")';\n    } else {\n      entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const webApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"MOBILE_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const mobileApps = await monitoredEntitiesClient.getEntities(config);\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n    } else {\n      entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n    }\n    config = { from: `now-7d`, entitySelector: entitySelector};\n    const customApps = await monitoredEntitiesClient.getEntities(config);\n    const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n    // Compute the ratio between synthetic monitors and monitored apps\n    const syntheticRatio = objects.totalCount / monitoredApps;\n    // Compute local score based on above ratio\n    const score = syntheticRatio >= 3 ? 1 : (syntheticRatio >= 1 ? 0.5 : 0);\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ In average, at least 3 synthetic monitors cover each monitored app`;\n        break;\n      case score === 0.5:\n        result = `üí° For each app, monitor your Top3 user scenarios and backend endpoints with synthetic tests`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è For each app, monitor your Top3 user scenarios and backend endpoints with synthetic tests`;\n        break;\n    }\n   // Return the emojied recommendation\n   return result;\n  } else {\n    return `Select the \"syntheticMonitors\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"137":{"type":"code","title":"","input":"import { settingsObjectsClient, monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"managementZones\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:management-zones'};\n      let mz = await settingsObjectsClient.getSettingsObjects(config);\n      config = { from: \"now-1d\", entitySelector: 'type(\"APPLICATION\")'};\n      const webApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-1d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n      const mobileApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-1d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n      const customApps = await monitoredEntitiesClient.getEntities(config);\n      // Count monitored apps\n      const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n      config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")', fields: 'managementZones', pageSize: 500};\n      const objects = await monitoredEntitiesClient.getEntities(config);\n      // Count apps with no management zone\n      const appsWithNoMz = objects.entities.filter(el => el.managementZones.length === 0);\n      const score = appsWithNoMz.length === 0 ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ All monitored apps are part of a specific management zone`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è For better access management and analysis, include each monitored app in a specific management zone`;\n          break;\n      }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review apps with no management zone`;\n    }\n  } else {\n    return `Select the \"managementZones\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"138":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"autoTags\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:tags.auto-tagging'};\n      // Get all auto tags\n      let objects = await settingsObjectsClient.getSettingsObjects(config);\n      // Compute local score based on the number of auto tags\n      const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 3 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging auto-tagging`;\n          break;\n        case score === 0.5:\n          result = `üí° Implement new auto-tagging rules to better organize and exploit your Dynatrace tenant`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Implement auto-tagging rules to better organize and exploit your Dynatrace tenant`;\n          break;\n      }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review auto-tags`;\n    }\n  } else {\n    return `Select the \"autoTags\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"139":{"type":"code","title":"","input":"import { monitoredEntitiesCustomTagsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"manualTags\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    let allCustomTags = [];\n    // Define list of entities to get manual tags for\n    let entityTypes = ['SYNTHETIC_TEST', 'APPLICATION', 'MOBILE_APPLICATION', 'CUSTOM_APPLICATION', 'SERVICE', 'PROCESS_GROUP', 'HOST'];\n    // For entity type, retrieve the list of manual tags\n    for(let entityType of entityTypes) {\n      let entitySelector;\n      if(scope === \"Tenant\") {\n        entitySelector = `type(\"${entityType}\")`;\n      } else {\n        entitySelector = `type(\"${entityType}\"),mzName(${scope})`;\n      }\n      let customTags = await monitoredEntitiesCustomTagsClient.getTags({ entitySelector: entitySelector });\n      customTags = customTags.tags.map(el => el.key);\n      allCustomTags = [...allCustomTags, ...customTags];\n    }\n    // Compute local score based on the number of manual tags\n    if($Scope[0] === \"Tenant\") {\n      const score = allCustomTags.length < 50 ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging manual tags in a balanced way`;\n          break;\n        case score === 0:\n          result = `üí° Restrict the use of manual tags to scenarios where auto-tagging is technically not possible`;\n          break;\n      }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Restrict the use of manual tags to scenarios where auto-tagging is technically not possible`;\n    }\n  } else {\n    return `Select the \"manualTags\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"140":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"integrations\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:problem.notifications'};\n      // Get all problem notifications set up\n      const integrations = await settingsObjectsClient.getSettingsObjects(config);\n      config = { schemaIds: 'builtin:alerting.profile'};\n      // Get all alerting profiles\n      const alertingProfiles = await settingsObjectsClient.getSettingsObjects(config);\n      // Compute the number of notification pipelines per alerting profile, and corresponding local score\n      const score = integrations.totalCount >= alertingProfiles.totalCount * 1.5 ? 1 : (integrations.totalCount >= alertingProfiles.totalCount ? 0.5 : 0);\n      let result;\n        switch(true) {\n        case score === 1:\n          result = `‚úÖ You often set up several integrations for your alerting profiles`;\n          break;\n        case score === 0.5:\n          result = `üí° You should set up several integrations for each of your alerting profiles`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Some of your alerting profiles are not associated to any problem notification pipeline`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review integrations`;\n    }\n  } else {\n    return `Select the \"integrations\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"141":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nfunction onlyUnique(value, index, array) {\n  return array.indexOf(value) === index;\n}\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"integrationTypes\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:problem.notifications'};\n      // Get all problem notifications set up\n      const objects = await settingsObjectsClient.getSettingsObjects(config);\n      // Retrieve the integration type of each notification configuration\n      let integrationTypes = [];\n      for(let object of objects.items) {\n        integrationTypes.push(object.value.type);\n      }\n      // Count the number of unique integration type\n      integrationTypes = integrationTypes.filter(onlyUnique);\n      // Compute local score based on above number\n      const score = integrationTypes.length >= 5 ? 1 : (integrationTypes.length >= 2 ? 0.5 : 0);\n      let result;\n        switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging diverse types of notification pipelines`;\n          break;\n        case score === 0.5:\n          result = `üí° Push problem notifications to new channels (eg. Slack, Teams,...) according to the ops team and criticity`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Push problem notifications to diverse channels (eg. Slack, Teams,...) according to the ops team and criticity`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review integration types`;\n    }\n  } else {\n    return `Select the \"integrationTypes\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"142":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"alertingProfiles\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:management-zones'};\n      // Get all management zones\n      const mz = await settingsObjectsClient.getSettingsObjects(config);\n      config = { schemaIds: 'builtin:alerting.profile'};\n      // Get all alerting profiles\n      const alertingProfiles = await settingsObjectsClient.getSettingsObjects(config);\n      // Compute the ratio of management zones per alerting profile and corresponding local score\n      const score = alertingProfiles.totalCount >= mz.totalCount ? 1 : (alertingProfiles.totalCount >= 5 ? 0.5 : 0);\n      let result;\n        switch(true) {\n        case score === 1:\n          result = `‚úÖ In average, you're assigning at least 1 management zone per alerting profile`;\n          break;\n        case score === 0.5:\n          result = `üí° Assign your alerting profiles to relevant management zones to alert people on incidents that matter to them`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Assign your alerting profiles to relevant management zones to alert people on incidents that matter to them`;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review alerting profiles`;\n    }\n  } else {\n    return `Select the \"alertingProfiles\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"143":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"metricEvents\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:anomaly-detection.metric-events', pageSize: 500};\n      // Get all metric events\n      let objects = await settingsObjectsClient.getSettingsObjects(config);\n      let metricEvents = objects.items;\n      while(objects.nextPageKey) {\n        config = { nextPageKey: objects.nextPageKey };\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n        metricEvents = [...metricEvents, ...objects.items];\n      }\n      // Filter the enabled metric events\n      const enabledMetricEventCount = metricEvents.filter(el => el.value.enabled).length;\n      // Compute local score based on above number\n      const score = enabledMetricEventCount >= 5 ? 1 : 0;\n      let result;\n        switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging metric events`;\n          break;\n        case score === 0:\n          result = `üí° Define metric events to alert on situations not considered natively by Davis`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review metric events`;\n    }\n  } else {\n    return `Select the \"metricEvents\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"144":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"slos\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      const config = { schemaIds: 'builtin:monitoring.slo'};\n      try {\n        // Get all SLOs\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Filter enabled SLOs\n      let enabledSlos = 0;\n      if(objects) {\n        for(let slo of objects.items) {\n          if(slo.value.enabled) enabledSlos++;\n        }\n      }\n      // Compute local score based on the number of enabled SLOs\n      const score = enabledSlos >= 10 ? 1 : (enabledSlos > 0 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging SLOs`;\n          break;\n        case score === 0.5:\n          result = `üí° Define new SLOs to focus on improving your quality of service`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Define SLOs to focus on improving your quality of service`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review SLOs`;\n    }\n  } else {\n    return `Select the \"slos\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"145":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"releaseIntegrations\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      const config = { schemaIds: 'builtin:issue-tracking.integration'};\n      try {\n        // Get all issue tracking systems integrated with Dynatrace\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Filter the enabled tracking system integrations\n      let enabledIssueTrackingSystems = 0;\n      if(objects) {\n        for(let enabledIssueTrackingSystem of objects.items) {\n          if(enabledIssueTrackingSystem.value.enabled) enabledIssueTrackingSystems++;\n        }\n      }\n      // Compute local score based on the number of tracking system integrations\n      const score = enabledIssueTrackingSystems >= 5 ? 1 : (enabledIssueTrackingSystems >= 2 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You connected your issue tracking systems`;\n          break;\n        case score === 0.5:\n          result = `üí° Connect your issue-tracking systems to pull issue statistics for monitored entities into Dynatrace for release analysis`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Connect your issue-tracking systems to pull issue statistics for monitored entities into Dynatrace for release analysis`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review release integrations`;\n    }\n  } else {\n    return `Select the \"releaseIntegrations\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"146":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"logMonitoring\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { schemaIds: 'builtin:logmonitoring.log-storage-settings'};\n      let objects = { items: [] };\n      try {\n        // Get log monitoring storage settings\n        objects = await settingsObjectsClient.getSettingsObjects(config);  \n      } catch(e) {}\n      // Count active log storage rules\n      const logStorageIncludeRules = objects.items.filter(el => el.value.enabled).length;\n      // Compute local score based on the number of log storage rules\n      const score = logStorageIncludeRules > 0 ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ Log monitoring is enabled. Extend your log storage inclusion rules when needed`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Verify Grail is ON and define log storage inclusion rules to start ingesting and analyzing your logs`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review Log Management and Analytics`;\n    }\n  } else {\n    return `Select the \"logMonitoring\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"147":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"thirdPartyVulnerabilityAnalytics\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      const config = { schemaIds: 'builtin:appsec.runtime-vulnerability-detection'};\n      try {\n        // Get runtime vulnerability detection settings\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Compute local score depending if runtime vulnerability detection is enabled\n    const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enableRuntimeVulnerabilityDetection ? 1 : 0;\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ 3rd-party Vulnerability Analytics is enabled`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è Enable 3rd-party Vulnerability Analytics to completely understand each vulnerability coming from 3rd-party software you use in your apps`;\n        break;\n      }\n   // Return the emojied recommendation\n   return result;\n    } else {\n      return `Select the \"Tenant\" scope to review 3rd party Vulnerability Analytics`;\n    }\n  } else {\n    return `Select the \"thirdPartyVulnerabilityAnalytics\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"148":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"codeLevelVulnerabilityAnalytics\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      const config = { schemaIds: 'builtin:appsec.runtime-vulnerability-detection'};\n      try {\n        // Get code-level vulnerability detection settings\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Compute local score depending if code-level vulnerability detection is enabled\n    const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enableCodeLevelVulnerabilityDetection ? 1 : 0;\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ Code-level Vulnerability Analytics is enabled`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è Enable Code-level Vulnerability Analytics to completely understand each vulnerability coming from your own code`;\n        break;\n      }\n   // Return the emojied recommendation\n   return result;\n    } else {\n      return `Select the \"Tenant\" scope to review Code-level Vulnerability Analytics`;\n    }\n  } else {\n    return `Select the \"codeLevelVulnerabilityAnalytics\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"149":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"runtimeApplicationProtection\")) {\n    if($Scope[0] === \"Tenant\") {\n      let objects;\n      const config = { schemaIds: 'builtin:appsec.attack-protection-settings'};\n      try {\n        // Get attack protection settings\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Compute local score depending if attack protection is enabled\n      const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enabled ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ Runtime Application Protection is enabled`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Enable Runtime Application Protection to let Dynatrace handle incoming attacks to your applications on a global scale`;\n          break;\n      }\n    // Return the emojied recommendation\n    return result;\n    } else {\n      return `Select the \"Tenant\" scope to review Runtime Application Protection`;\n    }\n  } else {\n    return `Select the \"runtimeApplicationProtection\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"150":{"type":"code","title":"","input":"import { metricsClient, monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\n// Helper function to filter duplicates\nfunction onlyUnique(value, index, array) {\n  return array.indexOf(value) === index;\n}\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"cloudIntegrations\")) {\n    if($Scope[0] === \"Tenant\") {\n      // Count cloud integrations\n      let config = { writtenSince: \"now-1d\", acceptType: \"application/json; charset=utf-8\", text: \"builtin:cloud\", pageSize: 500 };\n      let objects = await metricsClient.allMetrics(config);\n      let metrics = objects.metrics;\n      while(objects.nextPageKey) {\n        config = { acceptType: \"application/json; charset=utf-8\", nextPageKey: objects.nextPageKey };\n        objects = await metricsClient.allMetrics(config);\n        metrics = [...metrics, ...objects.metrics];\n      }\n      let cloudIntegrationCount = metrics.map(el => el.metricId.substring(\"builtin:cloud.\".length,(\"builtin:cloud.\".length + el.metricId.substring(\"builtin:cloud.\".length).indexOf(\".\")))).filter(onlyUnique).length;\n      // Count Kubernetes integrations\n      config = { from: \"now-1d\", entitySelector: `type(\"KUBERNETES_CLUSTER\")` };\n      objects = await monitoredEntitiesClient.getEntities(config);\n      if(objects.totalCount) cloudIntegrationCount++;\n      // Compute local score based on the number of cloud integrations configured\n      const score = cloudIntegrationCount >= 3 ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You've integrated with several cloud providers and/or Kubernetes clusters`;\n          break;\n        case score === 0:\n          result = `üí° Make sure you integrate your cloud providers and Kubernetes clusters to benefit from maximal observability and automation`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review cloud integrations`;\n    }\n  } else {\n    return `Select the \"cloudIntegrations\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"151":{"type":"code","title":"","input":"import { documentsClient } from '@dynatrace-sdk/client-document';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"dashboards\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { filter: \"type = 'dashboard'\"};\n      // Get all Dashboards from active user\n      let objects = await documentsClient.listDocuments(config);\n      // Compute local score based on the number of Dashboards from active user\n      const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 5 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging the new Dashboards`;\n          break;\n        case score === 0.5:\n          result = `üí° Create and share Dashboards from the new app for an improved observation of real-time answers`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Create and share Dashboards from the new app for an improved observation of real-time answers`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review Dashboards`;\n    }\n  } else {\n    return `Select the \"dashboards\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"152":{"type":"code","title":"","input":"import { documentsClient } from '@dynatrace-sdk/client-document';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"notebooks\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { filter: \"type = 'notebook'\"};\n      // Get all Notebooks from active user\n      let objects = await documentsClient.listDocuments(config);\n      // Compute local score based on the number of Notebooks from active user\n      const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 5 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging the new Notebooks`;\n          break;\n        case score === 0.5:\n          result = `üí° Collaborate on Notebooks to make your data tell a meaningful story`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Collaborate on Notebooks to make your data tell a meaningful story`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review Notebooks`;\n    }\n  } else {\n    return `Select the \"notebooks\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"153":{"type":"code","title":"","input":"import { metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"extensionConfigurations\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_monitoring_configuration_count:last(avg)'};\n      // Get the number of extension configurations\n      let objects = await metricsClient.query(config);\n      const extensionConfigCount = objects.result[0].data[0].values[0];\n      config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_count:last(avg)'};\n      // Get the number of extensions deployed\n      objects = await metricsClient.query(config);\n      const extensionCount = objects.result[0].data[0].values[0];\n      // Compute the ratio between extension configurations and extensions, and its corresponding local score\n      const score = extensionConfigCount >= extensionCount * 1.5 ? 1 : (extensionConfigCount >= extensionCount ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You often set up several configurations for your deployed extensions`;\n          break;\n        case score === 0.5:\n          result = `üí° You should set up several configurations foreach of your deployed extensions`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Some of your deployed extensions are not configured`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review extensions`;\n    }\n  } else {\n    return `Select the \"extensionConfigurations\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"154":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"networkZones\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { schemaIds: 'builtin:networkzones'};\n      // Get network zones\n      const objects = await settingsObjectsClient.getSettingsObjects(config);\n      // Compute local score based on the number of network zones\n      const score = objects.totalCount > 0 ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging Network Zones`;\n          break;\n        case score === 0:\n          result = `üí° Define Network Zones to optimize your monitoring data transit from your OneAgents to the Dynatrace tenant`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review network zones`;\n    }\n  } else {\n    return `Select the \"networkZones\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"155":{"type":"code","title":"","input":"import { metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"extensions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_count:last(avg)'};\n      // Get the number of extensions deployed\n      const objects = await metricsClient.query(config);\n      const extensionCount = objects.result[0].data[0].values[0];\n      // Compute local score based on above number\n      const score = extensionCount >= 10 ? 1 : (extensionCount > 0 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging extensions. Keep an eye on the Dynatrace Hub for incoming ones`;\n          break;\n        case score === 0.5:\n          result = `üí° Explore the Dynatrace Hub to deploy extensions and expand your observability to new technologies`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Explore the Dynatrace Hub to deploy your first extension and expand your observability to a new technology`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review extension configurations`;\n    }\n  } else {\n    return `Select the \"extensions\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"156":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"ownershipTeams\")) {\n    if($Scope[0] === \"Tenant\") {\n      let config = { schemaIds: 'builtin:ownership.teams'};\n      // Get ownership teams configured\n      const objects = await settingsObjectsClient.getSettingsObjects(config);\n      // Compute local score based on the number of ownership teams configured\n      const score = objects.items.length >= 10 ? 1 : (objects.items.length >= 5 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging ownership teams`;\n          break;\n        case score === 0.5:\n          result = `üí° Leverage ownership teams to reduce Mean-Time-To-Repair and boost collaboration`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Leverage ownership teams to reduce Mean-Time-To-Repair and boost collaboration`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review Runtime Application Protection`;\n    }\n  } else {\n    return `Select the \"ownershipTeams\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"157":{"type":"code","title":"","input":"import { settingsObjectsClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"auditLogs\")) {\n    if($Scope[0] === \"Tenant\") {\n      const config = { schemaIds: 'builtin:audit-log'};\n      let objects;\n      try {\n        // Get audit log settings\n        objects = await settingsObjectsClient.getSettingsObjects(config);\n      } catch(e) {}\n      // Check if it's enabled and compute local score accordingly\n      const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enabled ? 1 : 0;\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ Audit Logs are enabled`;\n          break;\n        case score === 0:\n          result = `üí° Enable Audit Logs to better track changes applied to your environment`;\n          break;\n        }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review Runtime Application Protection`;\n    }\n  } else {\n    return `Select the \"auditLogs\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"158":{"type":"code","title":"","input":"import { metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"oneAgentVersions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n      const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n      const config = { from: \"now-5m\", acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:cluster.oneagent.agent_modules:filter(and(or(eq(\"dt.oneagent.agent_type\",os)))):splitBy(\"dt.oneagent.version\"):sum:last():sort(value(sum,descending)):limit(100)'};\n      // Get OneAgents count per version\n      const objects = await metricsClient.query(config);\n      const oneAgentVersionStats = {\n        records: [],\n        types: [\n          {\n            mappings: {\n              oneAgentVersion: {\n                type: \"string\"\n              },\n              running: {\n                type: \"long\"\n              }\n            },\n            indexRange: [\n              0,\n              1\n            ]\n          }\n        ]\n      };\n      let unsupportedOneAgentCount = 0;\n      // For each OneAgent version, evaluate its age category and add emoji accordingly\n      for(let oneAgentVersionData of objects.result[0].data) {\n        const oneAgentVersion = oneAgentVersionData.dimensionMap['dt.oneagent.version'];\n        // Compute local score depending if there are unsupported OneAgents running\n        const score = oneAgentVersion.substring(2) >= (latestVersion - 6) ? 1 : (oneAgentVersion.substring(2) >= oldestSupportedVersion ? 0.5 : 0);\n        let result = {};\n        switch(true) {\n          case score === 1:\n            result.oneAgentVersion = `‚úÖ ${oneAgentVersion}`;\n            break;\n          case score === 0.5:\n            result.oneAgentVersion = `üí° ${oneAgentVersion}`;\n            break;\n          case score === 0:\n            result.oneAgentVersion = `‚ö†Ô∏è ${oneAgentVersion}`;\n            break;\n        }\n        result.running = oneAgentVersionData.values[0];\n        oneAgentVersionStats.records.push(result);\n        if(oneAgentVersion.substring(2) < oldestSupportedVersion) unsupportedOneAgentCount += oneAgentVersionData.values[0];\n      }\n      const score = oneAgentVersionStats.records.findIndex(el => el.oneAgentVersion.substring(4) < (latestVersion - 6)) === -1 ? 1 : (oneAgentVersionStats.records.findIndex(el => el.oneAgentVersion.substring(4) < oldestSupportedVersion) === -1 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ All deployed OneAgents were recently updated`;\n          break;\n        case score === 0.5:\n          result = `üí° Some older OneAgents should be updated to benefit from the latest features and performance`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Some OneAgents are running an unsupported version. Update them when possible`;\n          break;\n      }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review deployed OneAgent versions with no management zone`;\n    }\n  } else {\n    return `Select the \"oneAgentVersions\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"159":{"type":"code","title":"","input":"import { activeGatesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"activeGateVersions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n      const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n      // Get all ActiveGates\n      const objects = await activeGatesClient.getAllActiveGates();\n      let unsupportedActiveGateCount = 0;\n      // Count unsupported ActiveGates\n      for(let activeGate of objects.activeGates) {\n        if(activeGate.version.substring(2, 5) < oldestSupportedVersion) unsupportedActiveGateCount++;\n      }\n      // Compute local score based on above number\n      const score = objects.activeGates.findIndex(el => el.version.substring(2, 5) < oldestSupportedVersion) > -1 ? 0 : (objects.activeGates.findIndex(el => el.version.substring(2, 5) < (latestVersion - 6)) > -1 ? 0.5 : 1);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ All deployed ActiveGates were recently updated`;\n          break;\n        case score === 0.5:\n          result = `üí° Some older ActiveGates should be updated to benefit from the latest features and performance`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Some ActiveGates are running an unsupported version. Update them when possible`;\n          break;\n      }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review ActiveGates`;\n    }\n  } else {\n    return `Select the \"activeGateVersions\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"160":{"type":"code","title":"","input":"import {\n  monitoredEntitiesClient,\n  settingsObjectsClient,\n  metricsClient,\n  monitoredEntitiesCustomTagsClient,\n  activeGatesClient\n} from '@dynatrace-sdk/client-classic-environment-v2';\nimport { rumUserSessionsClient } from \"@dynatrace-sdk/client-classic-environment-v1\";\n\nimport { documentsClient } from '@dynatrace-sdk/client-document';\n\n// Function to add warnings to the We app name if that's the default catch-all app\nfunction filterEntry(el) {\n  const filteredEntry = {};\n  filteredEntry[\"Monitored apps:\"] = el.displayName === \"My web application\" ? \"‚ö†Ô∏è My web application ‚ö†Ô∏è\" : el.displayName;\n  return filteredEntry;\n}\n\n// Helper function to filter unique names\nfunction onlyUnique(value, index, array) {\n  return array.indexOf(value) === index;\n}\n\n// Function to get the weight of a specific indicator\nasync function getWeightedScore(indicator) {\n  const score = await indicator();\n  const weightedScore = score * indicatorWeights[indicator.name];\n  return weightedScore;\n}\n\n// Function to get the maximum total score expected for a selection of indicators\nfunction getMaxWeightedTotalScore(indicators) {\n  let maxWeightedTotalScore = 0;\n  for(let indicator of indicators) {\n    maxWeightedTotalScore += indicatorWeights[indicator.name]\n  }\n  return maxWeightedTotalScore;\n}\n\n// Each indicator can have a weight of 1, 2 or 3 for \"Important\", \"Best practice\" or \"Fundamental\" levels of importance\nconst indicatorWeights = {\n  fullStackCoverage: 3,\n  candidates: 2,\n  hostGroups: 2,\n  hostGroupCoverage: 3,\n  uniqueProcessGroups: 2,\n  declarativeProcessGroupings: 1,\n  uniqueServices: 2,\n  customServices: 1,\n  osServices: 2,\n  serviceKeyRequests: 2,\n  calculatedServiceMetrics: 2,\n  webApps: 2,\n  androidApps: 2,\n  iosApps: 2,\n  userTagCoverage: 2,\n  uscm: 2,\n  syntheticMonitors: 3,\n  managementZones: 3,\n  autoTags: 2,\n  manualTags: 1,\n  alertingProfiles: 2,\n  integrations: 2,\n  integrationTypes: 2,\n  metricEvents: 2,\n  slos: 2,\n  releaseIntegrations: 1,\n  logMonitoring: 2,\n  thirdPartyVulnerabilityAnalytics: 2,\n  codeLevelVulnerabilityAnalytics: 2,\n  runtimeApplicationProtection: 2,\n  dashboards: 1,\n  notebooks: 1,\n  cloudIntegrations: 2,\n  extensions: 1,\n  extensionConfigurations: 1,\n  networkZones: 1,\n  ownershipTeams: 2,\n  auditLogs: 1,\n  oneAgentVersions: 2,\n  activeGateVersions: 2\n}\n\n// List indicators that can be evaluated in a tenant scope\nconst tenantIndicators = [\n  fullStackCoverage,\n  candidates,\n  hostGroups,\n  hostGroupCoverage,\n  uniqueProcessGroups,\n  declarativeProcessGroupings,\n  uniqueServices,\n  customServices,\n  osServices,\n  serviceKeyRequests,\n  calculatedServiceMetrics,\n  webApps,\n  androidApps,\n  iosApps,\n  userTagCoverage,\n  uscm,\n  syntheticMonitors,\n  managementZones,\n  autoTags,\n  manualTags,\n  alertingProfiles,\n  integrations,\n  integrationTypes,\n  metricEvents,\n  slos,\n  releaseIntegrations,\n  logMonitoring,\n  thirdPartyVulnerabilityAnalytics,\n  codeLevelVulnerabilityAnalytics,\n  runtimeApplicationProtection,\n  dashboards,\n  notebooks,\n  cloudIntegrations,\n  extensions,\n  extensionConfigurations,\n  networkZones,\n  ownershipTeams,\n  auditLogs,\n  oneAgentVersions,\n  activeGateVersions\n];\n\n// List indicators that can be evaluated in a management zone scope\nconst managementZoneIndicators = [\n  fullStackCoverage,\n  hostGroups,\n  hostGroupCoverage,\n  uniqueProcessGroups,\n  uniqueServices,\n  customServices,\n  serviceKeyRequests,\n  webApps,\n  androidApps,\n  iosApps,\n  syntheticMonitors,\n  oneAgentVersions\n];\n\n// Find below an async function that returns the local score (1, 0.5 or 0) for each indicator\nasync function fullStackCoverage() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"HOST\"),monitoringMode(\"FULL_STACK\")';\n  } else {\n    entitySelector = `type(\"HOST\"),monitoringMode(\"FULL_STACK\"),mzName(${scope})`;\n  }\n  let config = { from: \"now-1d\", entitySelector: entitySelector};\n  const fullStackHosts = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false)';\n  } else {\n    entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),mzName(${scope})`;\n  }\n  config = { from: \"now-1d\", entitySelector: entitySelector};\n  const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n  const fullStackCoverage = Math.round(fullStackHosts.totalCount/monitoredHosts.totalCount*100);\n  const score = fullStackCoverage === 100 ? 1 : (fullStackCoverage >= 80 ? 0.5 : 0);\n  return score;\n}\n\nasync function candidates() {\n  let config = { from: `now-1d`, entitySelector: 'type(\"HOST\"),isMonitoringCandidate(false)'};\n  const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n  config = { from: `now-1d`, entitySelector: 'type(\"HOST\"),isMonitoringCandidate(true)'};\n  const monitoringCandidates = await monitoredEntitiesClient.getEntities(config);\n  const score = monitoringCandidates.totalCount === 0 ? 1 : (monitoringCandidates.totalCount < 50 ? 0.5 : 0);\n  return score;\n}\n\nasync function hostGroups() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"HOST_GROUP\")';\n  } else {\n    entitySelector = `type(\"HOST_GROUP\"),toRelationships.isInstanceOf(type(\"HOST\"),mzName(${scope}))`;\n  }\n  let config = { from: `now-7d`, entitySelector: entitySelector};\n  const hostGroups = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const hostGroupAppRatio = hostGroups.totalCount/(webApps.totalCount + mobileApps.totalCount + customApps.totalCount);\n  const score = hostGroupAppRatio >= 1 ? 1 : (hostGroupAppRatio >= 0.8 ? 0.5 : 0);\n  return score;\n}\n\nasync function hostGroupCoverage() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false)';\n  } else {\n    entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),mzName(${scope})`;\n  }\n  let config = { from: `now-1d`, entitySelector: entitySelector};\n  const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false),fromRelationships.isInstanceOf(type(\"HOST_GROUP\"))';\n  } else {\n    entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),fromRelationships.isInstanceOf(type(\"HOST_GROUP\")),mzName(${scope})`;\n  }\n  config = { from: `now-1d`, entitySelector: entitySelector};\n  const hostsWithHostGroup = await monitoredEntitiesClient.getEntities(config);\n  const hostGroupCoverage = Math.round(hostsWithHostGroup.totalCount/monitoredHosts.totalCount*100);\n  const score = hostGroupCoverage === 100 ? 1 : (hostGroupCoverage >= 80 ? 0.5 : 0);\n  return score;\n}\n\nasync function uniqueProcessGroups() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"PROCESS_GROUP\")';\n  } else {\n    entitySelector = `type(\"PROCESS_GROUP\"),mzName(${scope})`;\n  }\n  let config = { from: \"now-1d\", entitySelector: entitySelector, pageSize: 12000 };\n  let objects = await monitoredEntitiesClient.getEntities(config);\n  const processGroupsCount = objects.totalCount;\n  let processGroups = objects.entities;\n  while(objects.nextPageKey) {\n    config = { nextPageKey: objects.nextPageKey };\n    objects = await monitoredEntitiesClient.getEntities(config);\n    processGroups = [...processGroups, ...objects.entities];\n  }\n  const lookup = processGroups.reduce((a, e) => {\n    a[e.displayName] = ++a[e.displayName] || 0;\n    return a;\n  }, {});\n  const duplicates = processGroups.filter(e => lookup[e.displayName]);\n  const uniqueProcessGroupRatio = 100 - parseInt(duplicates.length / processGroupsCount * 100);\n  const score = uniqueProcessGroupRatio === 100 ? 1 : (uniqueProcessGroupRatio >= 95 ? 0.5 : 0);\n  return score;\n}\n\nasync function declarativeProcessGroupings() {\n  let config = { schemaIds: 'builtin:declarativegrouping'};\n  const declarativeGroupings = await settingsObjectsClient.getSettingsObjects(config);\n  config = { from: `now-1d`, entitySelector: 'type(\"PROCESS_GROUP\")'};\n  const processGroups = await monitoredEntitiesClient.getEntities(config);\n  const declarativeGroupingRatio = declarativeGroupings.totalCount / processGroups.totalCount;\n  const score = declarativeGroupingRatio > 0.0001 ? 1 : 0;\n  return score;\n}\n\nasync function uniqueServices() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"SERVICE\")';\n  } else {\n    entitySelector = `type(\"SERVICE\"),mzName(${scope})`;\n  }\n  let config = { from: \"now-1d\", entitySelector: entitySelector, pageSize: 12000 };\n  let objects = await monitoredEntitiesClient.getEntities(config);\n  const servicesCount = objects.totalCount;\n  let services = objects.entities;\n  while(objects.nextPageKey) {\n    config = { nextPageKey: objects.nextPageKey };\n    objects = await monitoredEntitiesClient.getEntities(config);\n    services = [...services, ...objects.entities];\n  }\n  const lookup = services.reduce((a, e) => {\n    a[e.displayName] = ++a[e.displayName] || 0;\n    return a;\n  }, {});\n  const duplicates = services.filter(e => lookup[e.displayName]);\n  const uniqueServiceRatio = 100 - parseInt(duplicates.length / servicesCount * 100);\n  const score = uniqueServiceRatio === 100 ? 1 : (uniqueServiceRatio >= 95 ? 0.5 : 0);\n  return score;\n}\n\nasync function customServices() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"SERVICE\")';\n  } else {\n    entitySelector = `type(\"SERVICE\"),mzName(${scope})`;\n  }\n  let config = { from: \"now-1d\", entitySelector: entitySelector};\n  const services = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"SERVICE\"),serviceType(\"CUSTOM_SERVICE\")';\n  } else {\n    entitySelector = `type(\"SERVICE\"),serviceType(\"CUSTOM_SERVICE\"),mzName(${scope})`;\n  }\n  config = { from: \"now-1d\", entitySelector: entitySelector};\n  const customServices = await monitoredEntitiesClient.getEntities(config);\n  const customServiceRatio = customServices.totalCount / services.totalCount;\n  const score = customServiceRatio > 0.01 ? 1 : (customServiceRatio >= 0.001 ? 0.5 : 0);\n  return score;\n}\n\nasync function osServices() {\n  let config = { schemaIds: 'builtin:os-services-monitoring'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  const osServicesAlertingRules = objects.items.filter(el => el.value.enabled);\n  const score = osServicesAlertingRules.length > 1 ? 1 : (osServicesAlertingRules.length === 1 ? 0.5 : 0);\n  return score;\n}\n\nasync function serviceKeyRequests() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"SERVICE_METHOD\"),fromRelationships.isServiceMethodOfService(type(\"SERVICE\"))';\n  } else {\n    entitySelector = `type(\"SERVICE_METHOD\"),fromRelationships.isServiceMethodOfService(type(\"SERVICE\")),mzName(${scope})`;\n  }\n  let config = { from: \"now-1d\", entitySelector: entitySelector};\n  let objects = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  const serviceKeyRequestRatio = objects.totalCount / monitoredApps;\n  const score = (serviceKeyRequestRatio >= 3) ? 1 : (serviceKeyRequestRatio >= 1 ? 0.5 : 0);\n  return score;\n}\n\nasync function calculatedServiceMetrics() {\n  let config = { acceptType: \"application/json; charset=utf-8\", text: \"calc:service\" };\n  let objects = await metricsClient.allMetrics(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  const scmRatio = objects.totalCount / monitoredApps;\n  const score = scmRatio >= 3 ? 1 : (scmRatio >= 1 ? 0.5 : 0);\n  return score;\n}\n\nasync function webApps() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  const config = { from: `now-7d`, entitySelector: entitySelector};\n  const objects = await monitoredEntitiesClient.getEntities(config);\n  const score = (objects.entities.some(el => el.displayName === \"My web application\") || objects.totalCount === 0) ? 0 : 1;\n  return score;\n}\n\nasync function androidApps() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  let config = { from: `now-7d`, entitySelector: entitySelector};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const apps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"ANDROID\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"ANDROID\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const androidApps = await monitoredEntitiesClient.getEntities(config);\n  const androidAppRatio = androidApps.totalCount / apps;\n  const score = androidAppRatio >= 0.05 ? 1 : 0;\n  return score;\n}\n\nasync function iosApps() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  let config = { from: `now-7d`, entitySelector: entitySelector};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const apps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"IOS\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"IOS\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const iosApps = await monitoredEntitiesClient.getEntities(config);\n  const iosAppRatio = iosApps.totalCount / apps;\n  const score = iosAppRatio >= 0.05 ? 1 : 0;\n  return score;\n}\n\nasync function userTagCoverage() {\n  // Get user tagged apps\n  let userTaggedApps = await rumUserSessionsClient.getUsqlResultAsTable({\n    query: \"SELECT application FROM useraction WHERE (usersession.userId IS NOT NULL) GROUP BY application LIMIT 500\",\n    startTimestamp: (Date.now() - 7*24*60*60*1000),\n    pageSize: 500\n  });\n  // Get all apps\n  let config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  // compute user tag coverage\n  const userTaggedAppCoverage = parseInt((userTaggedApps.values.length / monitoredApps)*100);      \n  // Compute local score based on above number\n  const score = userTaggedAppCoverage >= 95 ? 1 : (userTaggedAppCoverage >= 80 ? 0.5 : 0);\n  return score;\n}\n\nasync function uscm() {\n  let config = { acceptType: \"application/json; charset=utf-8\", text: \"uscm.\" };\n  let objects = await metricsClient.allMetrics(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  const uscmRatio = objects.totalCount / monitoredApps;\n  const score = uscmRatio >= 3 ? 1 : (uscmRatio >= 1 ? 0.5 : 0);\n  return score;\n}\n\nasync function syntheticMonitors() {\n  // List all synthetic monitors\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"SYNTHETIC_TEST\")';\n  } else {\n    entitySelector = `type(\"SYNTHETIC_TEST\"),mzName(${scope})`;\n  }\n  let config = { from: `now-7d`, entitySelector: entitySelector};\n  const objects = await monitoredEntitiesClient.getEntities(config);\n  // Count monitored apps\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  const syntheticRatio = objects.totalCount / monitoredApps;\n  const score = syntheticRatio >= 3 ? 1 : (syntheticRatio >= 1 ? 0.5 : 0);\n  return score;\n}\n\nasync function managementZones() {\n  let config = { schemaIds: 'builtin:management-zones'};\n  let mz = await settingsObjectsClient.getSettingsObjects(config);\n  config = { from: \"now-1d\", entitySelector: 'type(\"APPLICATION\")'};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-1d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-1d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")', fields: 'managementZones', pageSize: 500};\n  const objects = await monitoredEntitiesClient.getEntities(config);\n  const appsWithNoMz = objects.entities.filter(el => el.managementZones.length === 0);\n  const score = appsWithNoMz.length === 0 ? 1 : 0;\n  return score;\n}\n\nasync function autoTags() {\n  const config = { schemaIds: 'builtin:tags.auto-tagging'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 3 ? 0.5 : 0);\n  return score;\n}\n\nasync function manualTags() {\n  let allCustomTags = [];\n  let entityTypes = ['SYNTHETIC_TEST', 'APPLICATION', 'MOBILE_APPLICATION', 'CUSTOM_APPLICATION', 'SERVICE', 'PROCESS_GROUP', 'HOST'];\n  for(let entityType of entityTypes) {\n    let customTags = await monitoredEntitiesCustomTagsClient.getTags({ entitySelector: `type(\"${entityType}\")` });\n    customTags = customTags.tags.map(el => el.key);\n    allCustomTags = [...allCustomTags, ...customTags];\n  }\n  const score = allCustomTags.length < 50 ? 1 : 0;\n  return score;\n}\n\nasync function alertingProfiles() {\n  let config = { schemaIds: 'builtin:management-zones'};\n  const mz = await settingsObjectsClient.getSettingsObjects(config);\n  config = { schemaIds: 'builtin:alerting.profile'};\n  const alertingProfiles = await settingsObjectsClient.getSettingsObjects(config);\n  const score = alertingProfiles.totalCount >= mz.totalCount ? 1 : (alertingProfiles.totalCount >= 5 ? 0.5 : 0);\n  return score;\n}\n\nasync function integrations() {\n  let config = { schemaIds: 'builtin:problem.notifications'};\n  const integrations = await settingsObjectsClient.getSettingsObjects(config);\n  config = { schemaIds: 'builtin:alerting.profile'};\n  const alertingProfiles = await settingsObjectsClient.getSettingsObjects(config);\n  const score = integrations.totalCount >= alertingProfiles.totalCount * 1.5 ? 1 : (integrations.totalCount >= alertingProfiles.totalCount ? 0.5 : 0);\n  return score;\n}\n\nasync function integrationTypes() {\n  let config = { schemaIds: 'builtin:problem.notifications'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  let integrationTypes = [];\n  for(let object of objects.items) {\n    integrationTypes.push(object.value.type);\n  }\n  integrationTypes = integrationTypes.filter(onlyUnique);\n  const score = integrationTypes.length >= 5 ? 1 : (integrationTypes.length >= 2 ? 0.5 : 0);\n  return score;\n}\n\nasync function metricEvents() {\n  let config = { schemaIds: 'builtin:anomaly-detection.metric-events', pageSize: 500};\n  let objects = await settingsObjectsClient.getSettingsObjects(config);\n  let metricEvents = objects.items;\n  while(objects.nextPageKey) {\n    config = { nextPageKey: objects.nextPageKey };\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n    metricEvents = [...metricEvents, ...objects.items];\n  }\n  const enabledMetricEventCount = metricEvents.filter(el => el.value.enabled).length;\n  const score = enabledMetricEventCount >= 5 ? 1 : 0;\n  return score;\n}\n\nasync function slos() {\n  let objects;\n  const config = { schemaIds: 'builtin:monitoring.slo'};\n  try {\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n  } catch(e) {}\n  let enabledSlos = 0;\n  if(objects) {\n    for(let slo of objects.items) {\n      if(slo.value.enabled) enabledSlos++;\n    }\n  }\n  const score = enabledSlos >= 10 ? 1 : (enabledSlos > 0 ? 0.5 : 0);\n  return score;\n}\n\nasync function releaseIntegrations() {\n  let objects;\n  const config = { schemaIds: 'builtin:issue-tracking.integration'};\n  try {\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n  } catch(e) {}\n  let enabledIssueTrackingSystems = 0;\n  if(objects) {\n    for(let enabledIssueTrackingSystem of objects.items) {\n      if(enabledIssueTrackingSystem.value.enabled) enabledIssueTrackingSystems++;\n    }\n  }\n  const score = enabledIssueTrackingSystems >= 5 ? 1 : (enabledIssueTrackingSystems >= 2 ? 0.5 : 0);\n  return score;\n}\n\nasync function logMonitoring() {\n  const config = { schemaIds: 'builtin:logmonitoring.log-storage-settings'};\n  let objects = { items: [] };\n      try {\n        objects = await settingsObjectsClient.getSettingsObjects(config);  \n      } catch(e) {}\n  const logStorageIncludeRules = objects.items.filter(el => el.value.enabled).length;\n  const score = logStorageIncludeRules > 0 ? 1 : 0;\n  return score;\n}\n\nasync function thirdPartyVulnerabilityAnalytics() {\n  let objects;\n  const config = { schemaIds: 'builtin:appsec.runtime-vulnerability-detection'};\n  try {\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n  } catch(e) {}\n  const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enableRuntimeVulnerabilityDetection ? 1 : 0;\n  return score;\n}\n\nasync function codeLevelVulnerabilityAnalytics() {\n  let objects;\n  const config = { schemaIds: 'builtin:appsec.runtime-vulnerability-detection'};\n  try {\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n  } catch(e) {}\n  const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enableCodeLevelVulnerabilityDetection ? 1 : 0;\n  return score;\n}\n\nasync function runtimeApplicationProtection() {\n  let objects;\n  const config = { schemaIds: 'builtin:appsec.attack-protection-settings'};\n  try {\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n  } catch(e) {}\n  const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enabled ? 1 : 0;\n  return score;\n}\n\nasync function dashboards() {\n  const config = { filter: \"type = 'dashboard'\"};\n  let objects = await documentsClient.listDocuments(config);\n  const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 5 ? 0.5 : 0);\n  return score;\n}\n\nasync function notebooks() {\n  const config = { filter: \"type = 'notebook'\"};\n  let objects = await documentsClient.listDocuments(config);\n  const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 5 ? 0.5 : 0);\n  return score;\n}\n\nasync function cloudIntegrations() {\n  // Count cloud integrations\n  let config = { writtenSince: \"now-1d\", acceptType: \"application/json; charset=utf-8\", text: \"builtin:cloud\", pageSize: 500 };\n  let objects = await metricsClient.allMetrics(config);\n  let metrics = objects.metrics;\n  while(objects.nextPageKey) {\n    config = { acceptType: \"application/json; charset=utf-8\", nextPageKey: objects.nextPageKey };\n    objects = await metricsClient.allMetrics(config);\n    metrics = [...metrics, ...objects.metrics];\n  }\n  let cloudIntegrationCount = metrics.map(el => el.metricId.substring(\"builtin:cloud.\".length,(\"builtin:cloud.\".length + el.metricId.substring(\"builtin:cloud.\".length).indexOf(\".\")))).filter(onlyUnique).length;\n  // Count Kubernetes integrations\n  config = { from: \"now-1d\", entitySelector: `type(\"KUBERNETES_CLUSTER\")` };\n  objects = await monitoredEntitiesClient.getEntities(config);\n  if(objects.totalCount) cloudIntegrationCount++;\n  const score = cloudIntegrationCount >= 3 ? 1 : 0;\n  return score;\n}\n\nasync function extensions() {\n  const config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_count:last(avg)'};\n  const objects = await metricsClient.query(config);\n  const extensionCount = objects.result[0].data[0].values[0];\n  const score = extensionCount >= 10 ? 1 : (extensionCount > 0 ? 0.5 : 0);\n  return score;\n}\n\nasync function extensionConfigurations() {\n  let config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_monitoring_configuration_count:last(avg)'};\n  let objects = await metricsClient.query(config);\n  const extensionConfigCount = objects.result[0].data[0].values[0];\n  config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_count:last(avg)'};\n  objects = await metricsClient.query(config);\n  const extensionCount = objects.result[0].data[0].values[0];\n  const score = extensionConfigCount >= extensionCount * 1.5 ? 1 : (extensionConfigCount >= extensionCount ? 0.5 : 0);\n  return score;\n}\n\nasync function networkZones() {\n  const config = { schemaIds: 'builtin:networkzones'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  const score = objects.totalCount > 0 ? 1 : 0;\n  return score;\n}\n\nasync function ownershipTeams() {\n  let config = { schemaIds: 'builtin:ownership.teams'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  const score = objects.items.length >= 10 ? 1 : (objects.items.length >= 5 ? 0.5 : 0);\n  return score;\n}\n\nasync function auditLogs() {\n  const config = { schemaIds: 'builtin:audit-log'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enabled ? 1 : 0;\n  return score;\n}\n\nasync function oneAgentVersions() {\n  const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n  const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n  let config = { from: \"now-5m\", acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:cluster.oneagent.agent_modules:filter(and(or(eq(\"dt.oneagent.agent_type\",os)))):splitBy(\"dt.oneagent.version\"):sum:last():sort(value(sum,descending)):limit(100)'};\n  let objects = await metricsClient.query(config);\n  const oneAgentVersionStats = {\n    records: [],\n    types: [\n      {\n        mappings: {\n          oneAgentVersion: {\n            type: \"string\"\n          },\n          running: {\n            type: \"long\"\n          }\n        },\n        indexRange: [\n          0,\n          1\n        ]\n      }\n    ]\n  };\n  for(let oneAgentVersion of objects.result[0].data) {\n    const score = oneAgentVersion.dimensionMap['dt.oneagent.version'].substring(2) >= (latestVersion - 6) ? 1 : (oneAgentVersion.dimensionMap['dt.oneagent.version'].substring(2) >= oldestSupportedVersion ? 0.5 : 0);\n    let result = {};\n    switch(true) {\n      case score === 1:\n        result.oneAgentVersion = `‚úÖ ${oneAgentVersion.dimensionMap['dt.oneagent.version']}`;\n        break;\n      case score === 0.5:\n        result.oneAgentVersion = `üí° ${oneAgentVersion.dimensionMap['dt.oneagent.version']}`;\n        break;\n      case score === 0:\n        result.oneAgentVersion = `‚ö†Ô∏è ${oneAgentVersion.dimensionMap['dt.oneagent.version']}`;\n        break;\n    }\n    result.running = oneAgentVersion.values[0];\n    oneAgentVersionStats.records.push(result);\n  }\n  const score = oneAgentVersionStats.records.findIndex(el => el.oneAgentVersion.substring(4) < (latestVersion - 6)) === -1 ? 1 : (oneAgentVersionStats.records.findIndex(el => el.oneAgentVersion.substring(4) < oldestSupportedVersion) === -1 ? 0.5 : 0);\n  return score;\n}\n\nasync function activeGateVersions() {\n  const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n  const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n  const objects = await activeGatesClient.getAllActiveGates();\n  const names = objects.activeGates.map(el => {\n    const filteredEntry = {};\n    switch(true) {\n    case el.version.substring(2,5) < oldestSupportedVersion:\n      filteredEntry.Version = `‚ö†Ô∏è ${el.version}`;\n      break;\n    case el.version.substring(2,5) < (latestVersion - 6):\n      filteredEntry.Version = `üí° ${el.version}`;\n      break;\n    default:\n      filteredEntry.Version = `‚úÖ ${el.version}`;\n    }\n    filteredEntry.ActiveGate = el.hostname;\n    return filteredEntry;\n  });\n  const score = names.findIndex(el => el.Version.substring(4,7) < (latestVersion - 6)) === -1 ? 1 : (names.findIndex(el => el.Version.substring(4,7) < oldestSupportedVersion) === -1 ? 0.5 : 0);\n  return score;\n}\n\nexport default async function() {\n  let totalWeightedScore = 0;\n  // Determine what indicators should be evaluated based on the selected DTR scope\n  let scopedIndicators;\n  if($Scope[0] === \"Tenant\") {\n    scopedIndicators = tenantIndicators;\n  } else {\n    scopedIndicators = managementZoneIndicators;\n  }\n  // Determine what indicators should be evaluated based on the selected indicators\n  let selectedIndicators = [];\n  if($Indicators[0] === \"All\") {\n    selectedIndicators = scopedIndicators;\n  } else {\n    for(let scopedIndicator of scopedIndicators) {\n      if($Indicators.includes(scopedIndicator.name)) {\n        selectedIndicators.push(scopedIndicator); \n      }\n    }\n  }\n  // Evaluate indicators and increment totalWeightedScore by their weighted local score\n  for(let selectedIndicator of selectedIndicators) {\n    totalWeightedScore += await getWeightedScore(selectedIndicator);\n  }\n  // Compute what's the maximum weighted score that can be expected based on the selected indicators\n  const maxWeightedTotalScore = getMaxWeightedTotalScore(selectedIndicators);\n  // Divide totalWeightedScore by maxWeightedTotalScore to get the totalScorePercent\n  const totalScorePercent = Math.floor((totalWeightedScore / maxWeightedTotalScore) * 100);\n  // Return the emojied totalScorePercent\n  let result;\n  switch(true) {\n    case totalScorePercent >= 95:\n      result = `‚≠ê ${totalScorePercent}%`;\n      break;\n    case totalScorePercent >= 80:\n      result = `‚úÖ ${totalScorePercent}%`;\n      break;\n    case totalScorePercent >= 50:\n      result = `üí° ${totalScorePercent}%`;\n      break;\n    default:\n      result = `‚ö†Ô∏è ${totalScorePercent}%`;\n  }\n  return result;\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Total Score","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"161":{"type":"markdown","title":"","content":" Synthesis:"},"162":{"type":"code","title":"","input":"export default async function() {\n  return 'Dynatrace Tenant Review';\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"163":{"type":"code","title":"","input":"export default async function() {\n  // Return the tenant ID\n  return globalThis.environmentUrl.substr(8,8);\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Evaluated tenant","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"164":{"type":"markdown","title":"","content":" "},"165":{"type":"markdown","title":"","content":"- DTR version: 1.7.0\n- [Propose an enhancement](https://dt-url.net/dtr-rfe)\n- [Latest version (internal-only)](https://dt-url.net/dtr)"},"168":{"type":"code","title":"","input":"import { metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"oneAgentVersions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n      const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n      const config = { from: \"now-5m\", acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:cluster.oneagent.agent_modules:filter(and(or(eq(\"dt.oneagent.agent_type\",os)))):splitBy(\"dt.oneagent.version\"):sum:last():sort(value(sum,descending)):limit(100)'};\n      // Get OneAgents count per version\n      const objects = await metricsClient.query(config);\n      const oneAgentVersionStats = {\n        records: [],\n        types: [\n          {\n            mappings: {\n              oneAgentVersion: {\n                type: \"string\"\n              },\n              running: {\n                type: \"long\"\n              }\n            },\n            indexRange: [\n              0,\n              1\n            ]\n          }\n        ]\n      };\n      let unsupportedOneAgentCount = 0;\n      // For each OneAgent version, evaluate its age category and add emoji accordingly\n      for(let oneAgentVersionData of objects.result[0].data) {\n        const oneAgentVersion = oneAgentVersionData.dimensionMap['dt.oneagent.version'];\n        // Compute local score depending if there are unsupported OneAgents running\n        const score = oneAgentVersion.substring(2) >= (latestVersion - 6) ? 1 : (oneAgentVersion.substring(2) >= oldestSupportedVersion ? 0.5 : 0);\n        let result = {};\n        switch(true) {\n          case score === 1:\n            result.oneAgentVersion = `‚úÖ ${oneAgentVersion}`;\n            break;\n          case score === 0.5:\n            result.oneAgentVersion = `üí° ${oneAgentVersion}`;\n            break;\n          case score === 0:\n            result.oneAgentVersion = `‚ö†Ô∏è ${oneAgentVersion}`;\n            break;\n        }\n        result.running = oneAgentVersionData.values[0];\n        oneAgentVersionStats.records.push(result);\n        if(oneAgentVersion.substring(2) < oldestSupportedVersion) unsupportedOneAgentCount += oneAgentVersionData.values[0];\n      }\n      const score = oneAgentVersionStats.records.findIndex(el => el.oneAgentVersion.substring(4) < (latestVersion - 6)) === -1 ? 1 : (oneAgentVersionStats.records.findIndex(el => el.oneAgentVersion.substring(4) < oldestSupportedVersion) === -1 ? 0.5 : 0);\n      let result = {};\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${unsupportedOneAgentCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${unsupportedOneAgentCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${unsupportedOneAgentCount}`;\n          break;\n      }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Unsupported OneAgents","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"171":{"type":"code","title":"","input":"import { metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"oneAgentVersions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n      const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n      let config = { from: \"now-5m\", acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:cluster.oneagent.agent_modules:filter(and(or(eq(\"dt.oneagent.agent_type\",os)))):splitBy(\"dt.oneagent.version\"):sum:last():sort(value(sum,descending)):limit(100)'};\n      // Get OneAgents count per version\n      let objects = await metricsClient.query(config);\n      let recentOneAgentCount = 0;\n      // Count OneAgents running with a recent version\n      for(let oneAgentVersionData of objects.result[0].data) {\n        const oneAgentVersion = oneAgentVersionData.dimensionMap['dt.oneagent.version'];\n        if(oneAgentVersion.substring(2) >= (latestVersion - 6)) recentOneAgentCount += oneAgentVersionData.values[0];\n      }\n      return recentOneAgentCount;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Recent OneAgents","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"172":{"type":"code","title":"","input":"import { metricsClient  } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"oneAgentVersions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n      const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n      let config = { from: \"now-5m\", acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:cluster.oneagent.agent_modules:filter(and(or(eq(\"dt.oneagent.agent_type\",os)))):splitBy(\"dt.oneagent.version\"):sum:last():sort(value(sum,descending)):limit(100)'};\n      // Get OneAgents count per version\n      let objects = await metricsClient.query(config);\n      let oldButSupportedOneAgentCount = 0;\n      // Count OneAgents running with a version that is old but still supported\n      for(let oneAgentVersionData of objects.result[0].data) {\n        const oneAgentVersion = oneAgentVersionData.dimensionMap['dt.oneagent.version'];\n        if((oneAgentVersion.substring(2) >= oldestSupportedVersion) && (oneAgentVersion.substring(2) < (latestVersion - 6))) oldButSupportedOneAgentCount += oneAgentVersionData.values[0];\n      }\n      return oldButSupportedOneAgentCount;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Old but supported OneAgents","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"173":{"type":"code","title":"","input":"import { activeGatesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"activeGateVersions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n      const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n      // Get all ActiveGates\n      const objects = await activeGatesClient.getAllActiveGates();\n      let unsupportedActiveGateCount = 0;\n      // Count unsupported ActiveGates\n      for(let activeGate of objects.activeGates) {\n        if(activeGate.version.substring(2, 5) < oldestSupportedVersion) unsupportedActiveGateCount++;\n      }\n      // Compute local score based on above number\n      const score = objects.activeGates.findIndex(el => el.version.substring(2, 5) < oldestSupportedVersion) > -1 ? 0 : (objects.activeGates.findIndex(el => el.version.substring(2, 5) < (latestVersion - 6)) > -1 ? 0.5 : 1);\n      let result = {};\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${unsupportedActiveGateCount}`;\n          break;\n        case score === 0.5:\n          result = `üí° ${unsupportedActiveGateCount}`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${unsupportedActiveGateCount}`;\n          break;\n      }\n     // Return the emojied result\n     return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Unsupported ActiveGates","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"175":{"type":"code","title":"","input":"import { activeGatesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"activeGateVersions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n      const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n      // Get all ActiveGates\n      const objects = await activeGatesClient.getAllActiveGates();\n      let oldButSupportedActiveGateCount = 0;\n      // Count ActiveGates running with a version that is old but still supported\n      for(let activeGate of objects.activeGates) {\n        if((activeGate.version.substring(2, 5) >= oldestSupportedVersion) && (activeGate.version.substring(2, 5) < (latestVersion - 6))) oldButSupportedActiveGateCount++;\n      }\n      return oldButSupportedActiveGateCount;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Old but supported ActiveGates","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"176":{"type":"code","title":"","input":"import { activeGatesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"activeGateVersions\")) {\n    if($Scope[0] === \"Tenant\") {\n      const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n      const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n      // Get all ActiveGates\n      const objects = await activeGatesClient.getAllActiveGates();\n      let recentActiveGateCount = 0;\n      // Count ActiveGates running with a recent version\n      for(let activeGate of objects.activeGates) {\n        if((activeGate.version.substring(2, 5) >= (latestVersion - 6))) recentActiveGateCount++;\n      }\n      return recentActiveGateCount;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Recent ActiveGates","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"177":{"type":"code","title":"","input":"import { monitoredEntitiesClient } from '@dynatrace-sdk/client-classic-environment-v2';\n\nexport default async function() {\n  // Check if that tile should be activated based on selected indicators and scope\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"uniqueServices\")) {\n    let scope;\n    if($Scope[0] === \"Tenant\") {\n      scope = 'Tenant';\n    } else {\n      let mzList = \"\";\n      for(let i=0; i<$Scope.length; i++) {\n        mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n      }\n      scope = mzList;\n    }\n    // Define entity selector based on the selected scope\n    let entitySelector;\n    if(scope === \"Tenant\") {\n      entitySelector = 'type(\"SERVICE\")';\n    } else {\n      entitySelector = `type(\"SERVICE\"),mzName(${scope})`;\n    }\n    let config = { from: \"now-1d\", entitySelector: entitySelector, pageSize: 12000 };\n    // Get all services\n    let objects = await monitoredEntitiesClient.getEntities(config);\n    const servicesCount = objects.totalCount;\n    let services = objects.entities;\n    // Loop through pagination\n    while(objects.nextPageKey) {\n      config = { nextPageKey: objects.nextPageKey };\n      objects = await monitoredEntitiesClient.getEntities(config);\n      services = [...services, ...objects.entities];\n    }\n    // Helper function for filtering duplicates\n    const lookup = services.reduce((a, e) => {\n      a[e.displayName] = ++a[e.displayName] || 0;\n      return a;\n    }, {});\n    // Get duplicate servces\n    const duplicates = services.filter(e => lookup[e.displayName]);\n    // Compute the ratio between services with unique name and all services\n    const uniqueServiceRatio = 100 - parseInt(duplicates.length / servicesCount * 100);\n    // Compute local score based on above ratio\n    const score = uniqueServiceRatio === 100 ? 1 : (uniqueServiceRatio >= 95 ? 0.5 : 0);\n    let result;\n    switch(true) {\n      case score === 1:\n        result = `‚úÖ ${uniqueServiceRatio}%`;\n        break;\n      case score === 0.5:\n        result = `üí° ${uniqueServiceRatio}%`;\n        break;\n      case score === 0:\n        result = `‚ö†Ô∏è ${uniqueServiceRatio}%`;\n        break;\n    }\n    // Return the emojied result\n    return result;\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"Unique services","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"178":{"type":"markdown","title":"","content":"About the DTR. It's:\n - Safe: The Dashboards app and the DTR are both restricted to read-only permissions/calls by design. No data ever leaves the Dynatrace tenant.\n - Fast: The analytics happens where the data resides, in Grail‚Ñ¢.\n - Open source: Copy, inspect, customize and share it in a few clicks."},"179":{"type":"markdown","title":"","content":" Legend:\n - ‚úÖ : Healthy\n - üí° : Opportunity of improvement\n - ‚ö†Ô∏è : Needs attention"},"180":{"type":"code","title":"","input":"import {\n  monitoredEntitiesClient,\n  settingsObjectsClient,\n  metricsClient,\n  monitoredEntitiesCustomTagsClient,\n  activeGatesClient\n} from '@dynatrace-sdk/client-classic-environment-v2';\nimport { rumUserSessionsClient } from \"@dynatrace-sdk/client-classic-environment-v1\";\n\nimport { documentsClient } from '@dynatrace-sdk/client-document';\n\n// Function to add warnings to the We app name if that's the default catch-all app\nfunction filterEntry(el) {\n  const filteredEntry = {};\n  filteredEntry[\"Monitored apps:\"] = el.displayName === \"My web application\" ? \"‚ö†Ô∏è My web application ‚ö†Ô∏è\" : el.displayName;\n  return filteredEntry;\n}\n\n// Helper function to filter unique names\nfunction onlyUnique(value, index, array) {\n  return array.indexOf(value) === index;\n}\n\n// Helper sorting function\nfunction sortArrayOfObjects(arr, propertyName, order = 'ascending') {\n  const sortedArr = arr.sort((a, b) => {\n    if (a[propertyName] < b[propertyName]) {\n      return -1;\n    }\n    if (a[propertyName] > b[propertyName]) {\n      return 1;\n    }\n    return 0;\n  });\n\n  if (order === 'descending') {\n    return sortedArr.reverse();\n  }\n\n  return sortedArr;\n};\n\n// Function that returns the result of evaluating an indicator\nasync function evaluate(indicator) {\n  const score = await indicator();\n  const weight = indicatorWeights[indicator.name];\n  let recommendation = indicatorRecommendations.find(e => e.indicator === indicator.name)[score];\n  return {\n    indicator: indicator.name,\n    weight: weight,\n    score: score,\n    recommendation: recommendation\n  };\n}\n\n// Function to get the maximum total score expected for a selection of indicators\nfunction getMaxWeightedTotalScore(indicators) {\n  let maxWeightedTotalScore = 0;\n  for(let indicator of indicators) {\n    maxWeightedTotalScore += indicatorWeights[indicator.name]\n  }\n  return maxWeightedTotalScore;\n}\n\n// Each indicator can have a weight of 1, 2 or 3 for \"Important\", \"Best practice\" or \"Fundamental\" levels of importance\nconst indicatorWeights = {\n  fullStackCoverage: 3,\n  candidates: 2,\n  hostGroups: 2,\n  hostGroupCoverage: 3,\n  uniqueProcessGroups: 2,\n  declarativeProcessGroupings: 1,\n  uniqueServices: 2,\n  customServices: 1,\n  osServices: 2,\n  serviceKeyRequests: 2,\n  calculatedServiceMetrics: 2,\n  webApps: 2,\n  androidApps: 2,\n  iosApps: 2,\n  userTagCoverage: 2,\n  uscm: 2,\n  syntheticMonitors: 3,\n  managementZones: 3,\n  autoTags: 2,\n  manualTags: 1,\n  alertingProfiles: 2,\n  integrations: 2,\n  integrationTypes: 2,\n  metricEvents: 2,\n  slos: 2,\n  releaseIntegrations: 1,\n  logMonitoring: 2,\n  thirdPartyVulnerabilityAnalytics: 2,\n  codeLevelVulnerabilityAnalytics: 2,\n  runtimeApplicationProtection: 2,\n  dashboards: 1,\n  notebooks: 1,\n  cloudIntegrations: 2,\n  extensions: 1,\n  extensionConfigurations: 1,\n  networkZones: 1,\n  ownershipTeams: 2,\n  auditLogs: 1,\n  oneAgentVersions: 2,\n  activeGateVersions: 2\n}\n\n// List recommendations for each score and each indicator\nconst indicatorRecommendations = [\n  {\n  indicator: \"fullStackCoverage\",\n  0: \"‚ö†Ô∏è Make sure you enable Full Stack monitoring on all hosts running code\",\n  0.5: \"üí° Regularly check if you could maximize the coverage of Full Stack monitoring\",\n  1: \"‚úÖ All hosts benefit from Full Stack monitoring\"\n},\n{\n  indicator: \"candidates\",\n  0: \"‚ö†Ô∏è Deploy the OneAgent on the many monitoring candidates discovered by Dynatrace\",\n  0.5: \"üí° Deploy the OneAgent on the remaining monitoring candidates\",\n  1: \"‚úÖ All discovered candidates are now monitored\"\n  },\n  {\n  indicator: \"hostGroups\",\n  0: \"‚ö†Ô∏è Assign a host group to all the servers running each monitored app\",\n  0.5: \"üí° Assign a host group to all the servers running each monitored app\",\n  1: \"‚úÖ There's more host groups than monitored apps\"\n},\n{\n  indicator: \"hostGroupCoverage\",\n  0: \"‚ö†Ô∏è Make sure you assign a group to each monitored host (eg. 'myapp-staging')\",\n  0.5: \"üí° Assign a group to all remaining hosts (eg. 'myapp-staging')\",\n  1: \"‚úÖ All monitored hosts are assigned a group\"\n},\n{\n  indicator: \"uniqueProcessGroups\",\n  0: \"‚ö†Ô∏è Define process group naming rules to have each process group monitored under a unique name\",\n  0.5: \"üí° Define process group naming rules to have each process group monitored under a unique name\",\n  1: \"‚úÖ All monitored process groups have a unique name\"\n},\n{\n  indicator: \"declarativeProcessGroupings\",\n  0: \"üí° You can define declarative process grouping rules to start monitoring unknown or low-consumption processes\",\n  1: \"‚úÖ You're leveraging declarative process grouping\"\n},\n{\n  indicator: \"uniqueServices\",\n  0: \"‚ö†Ô∏è Define service naming rules to have each service monitored under a unique name\",\n  0.5: \"üí° Define service naming rules to have each service monitored under a unique name\",\n  1: \"‚úÖ All monitored services have a unique name\"\n},\n{\n  indicator: \"customServices\",\n  0: \"‚ö†Ô∏è Define custom services to monitor entry points that Dynatrace couldn't model automatically\",\n  0.5: \"üí° Define custom services to monitor entry points that Dynatrace couldn't model automatically\",\n  1: \"‚úÖ You're leveraging custom services\"\n},\n{\n  indicator: \"osServices\",\n  0: \"‚ö†Ô∏è You should start leveraging OS services alerting rules to know when system services go south\",\n  0.5: \"üí° You should set up OS services alerting rules for more operating systems\",\n  1: \"‚úÖ You're leveraging OS services alerting rules\"\n},\n{\n  indicator: \"serviceKeyRequests\",\n  0: \"‚ö†Ô∏è Make sure to define important endpoints as Key Requests for more advanced monitoring\",\n  0.5: \"üí° Make sure to define important endpoints as Key Requests for more advanced monitoring\",\n  1: \"‚úÖ In average, there's more than 3 service key requests implemented per monitored app\"\n},\n{\n  indicator: \"calculatedServiceMetrics\",\n  0: \"‚ö†Ô∏è Define more calculated service metrics to cover your most important service-centric objectives\",\n  0.5: \"üí° Define more calculated service metrics to cover your most important service-centric objectives\",\n  1: \"‚úÖ You're leveraging calculated service metrics\"\n},\n{\n  indicator: \"webApps\",\n  0: \"‚ö†Ô∏è No app defined or traffic detected on the catch-all 'My Web Application', make sure to assign it to another RUM app\",\n  1: \"‚úÖ All RUM traffic gets assigned to its corresponding and explicitly-defined frontend app\"\n},\n{\n  indicator: \"androidApps\",\n  0: \"üí° Monitor your Android apps to make sure they provide the best experience\",\n  1: \"‚úÖ More than 5% of the apps you monitor are running on Android\"\n},\n{\n  indicator: \"iosApps\",\n  0: \"üí° Monitor your iOS apps to make sure they provide the best experience\",\n  1: \"‚úÖ More than 5% of the apps you monitor are running on iOS\"\n},\n{\n  indicator: \"userTagCoverage\",\n  0: \"‚ö†Ô∏è Define more user tag capturing rules to identify user sessions in a breeze\",\n  0.5: \"üí° Define more user tag capturing rules to identify user sessions in a breeze\",\n  1: \"‚úÖ You're leveraging user tagging\"\n},\n{\n  indicator: \"uscm\",\n  0: \"‚ö†Ô∏è Define more user session custom metrics to cover your most important user-centric objectives\",\n  0.5: \"üí° Define more user session custom metrics to cover your most important user-centric objectives\",\n  1: \"‚úÖ You're leveraging user session custom metrics\"\n},\n{\n  indicator: \"syntheticMonitors\",\n  0: \"‚ö†Ô∏è For each app, monitor your Top3 user scenarios and backend endpoints with synthetic tests\",\n  0.5: \"üí° For each app, monitor your Top3 user scenarios and backend endpoints with synthetic tests\",\n  1: \"‚úÖ In average, at least 3 synthetic monitors cover each monitored app\"\n},\n{\n  indicator: \"managementZones\",\n  0: \"‚ö†Ô∏è For better access management and analysis, include each monitored app in a specific management zone\",\n  1: \"‚úÖ All monitored apps are part of a specific management zone\"\n},\n{\n  indicator: \"autoTags\",\n  0: \"üí° Implement new auto-tagging rules to better organize and exploit your Dynatrace tenant\",\n  0.5: \"‚ö†Ô∏è Implement auto-tagging rules to better organize and exploit your Dynatrace tenant\",\n  1: \"‚úÖ You're leveraging auto-tagging\"\n},\n{\n  indicator: \"manualTags\",\n  0: \"üí° Restrict the use of manual tags to scenarios where auto-tagging is technically not possible\",\n  1: \"‚úÖ You're leveraging manual tags in a balanced way\"\n},\n{\n  indicator: \"alertingProfiles\",\n  0: \"üí° Assign your alerting profiles to relevant management zones to alert people on incidents that matter to them\",\n  0.5: \"‚ö†Ô∏è Assign your alerting profiles to relevant management zones to alert people on incidents that matter to them\",\n  1: \"‚úÖ In average, you're assigning at least 1 management zone per alerting profile\"\n},\n{\n  indicator: \"integrations\",\n  0: \"üí° You should set up several integrations for each of your alerting profiles\",\n  0.5: \"‚ö†Ô∏è Some of your alerting profiles are not associated to any problem notification pipeline\",\n  1: \"‚úÖ You often set up several integrations for your alerting profiles\"\n},\n{\n  indicator: \"integrationTypes\",\n  0: \"üí° Push problem notifications to new channels (eg. Slack, Teams,...) according to the ops team and criticity\",\n  0.5: \"‚ö†Ô∏è Push problem notifications to diverse channels (eg. Slack, Teams,...) according to the ops team and criticity\",\n  1: \"‚úÖ You're leveraging diverse types of notification pipelines\"\n},\n{\n  indicator: \"metricEvents\",\n  0: \"üí° Define metric events to alert on situations not considered natively by Davis\",\n  1: \"‚úÖ You're leveraging metric events\"\n},\n{\n  indicator: \"slos\",\n  0: \"‚ö†Ô∏è Define SLOs to focus on improving your quality of service\",\n  0.5: \"üí° Define new SLOs to focus on improving your quality of service\",\n  1: \"‚úÖ You're leveraging SLOs\"\n},\n{\n  indicator: \"releaseIntegrations\",\n  0: \"‚ö†Ô∏è Connect your issue-tracking systems to pull issue statistics for monitored entities into Dynatrace for release analysis\",\n  0.5: \"üí° Connect your issue-tracking systems to pull issue statistics for monitored entities into Dynatrace for release analysis\",\n  1: \"‚úÖ You connected your issue tracking systems\"\n},\n{\n  indicator: \"logMonitoring\",\n  0: \"‚ö†Ô∏è Verify Grail is ON and define log storage inclusion rules to start ingesting and analyzing your logs\",\n  1: \"‚úÖ Log monitoring is enabled. Extend your log storage inclusion rules when needed\"\n},\n{\n  indicator: \"thirdPartyVulnerabilityAnalytics\",\n  0: \"‚ö†Ô∏è Enable 3rd-party Vulnerability Analytics to completely understand each vulnerability coming from 3rd-party software you use in your apps\",\n  1: \"‚úÖ 3rd-party Vulnerability Analytics is enabled\"\n},\n{\n  indicator: \"codeLevelVulnerabilityAnalytics\",\n  0: \"‚ö†Ô∏è Enable Code-level Vulnerability Analytics to completely understand each vulnerability coming from your own code\",\n  1: \"‚úÖ Code-level Vulnerability Analytics is enabled\"\n},\n{\n  indicator: \"runtimeApplicationProtection\",\n  0: \"‚ö†Ô∏è Enable Runtime Application Protection to let Dynatrace handle incoming attacks to your applications on a global scale\",\n  1: \"‚úÖ Runtime Application Protection is enabled\"\n},\n{\n  indicator: \"dashboards\",\n  0: \"‚ö†Ô∏è Create and share Dashboards from the new app for an improved observation of real-time answers\",\n  0.5: \"üí° Create and share Dashboards from the new app for an improved observation of real-time answers\",\n  1: \"‚úÖ You're leveraging the new Dashboards\"\n},\n{\n  indicator: \"notebooks\",\n  0: \"‚ö†Ô∏è Collaborate on Notebooks to make your data tell a meaningful story\",\n  0.5: \"üí° Collaborate on Notebooks to make your data tell a meaningful story\",\n  1: \"‚úÖ You're leveraging the new Notebooks\"\n},\n{\n  indicator: \"cloudIntegrations\",\n  0: \"üí° Make sure you integrate your cloud providers and Kubernetes clusters to benefit from maximal observability and automation\",\n  1: \"‚úÖ You've integrated with several cloud providers and/or Kubernetes clusters\"\n},\n{\n  indicator: \"extensions\",\n  0: \"‚ö†Ô∏è Explore the Dynatrace Hub to deploy your first extension and expand your observability to a new technology\",\n  0.5: \"üí° Explore the Dynatrace Hub to deploy extensions and expand your observability to new technologies\",\n  1: \"‚úÖ You're leveraging extensions. Keep an eye on the Dynatrace Hub for incoming ones\"\n},\n{\n  indicator: \"extensionConfigurations\",\n  0: \"‚ö†Ô∏è Some of your deployed extensions are not configured\",\n  0.5: \"üí° You should set up several configurations foreach of your deployed extensions`\",\n  1: \"‚úÖ You often set up several configurations for your deployed extensions\"\n},\n{\n  indicator: \"networkZones\",\n  0: \"üí° Define Network Zones to optimize your monitoring data transit from your OneAgents to the Dynatrace tenant\",\n  1: \"‚úÖ You're leveraging Network Zones\"\n},\n{\n  indicator: \"ownershipTeams\",\n  0: \"‚ö†Ô∏è Leverage ownership teams to reduce Mean-Time-To-Repair and boost collaboration\",\n  0.5: \"üí° Leverage ownership teams to reduce Mean-Time-To-Repair and boost collaboration\",\n  1: \"‚úÖ You're leveraging ownership teams\"\n},\n{\n  indicator: \"auditLogs\",\n  0: \"üí° Enable Audit Logs to better track changes applied to your environment\",\n  1: \"‚úÖ Audit Logs are enabled\"\n},\n{\n  indicator: \"oneAgentVersions\",\n  0: \"‚ö†Ô∏è Some OneAgents are running an unsupported version. Update them when possible\",\n  0.5: \"üí° Some older OneAgents should be updated to benefit from the latest features and performance\",\n  1: \"‚úÖ All deployed OneAgents were recently updated\"\n},\n{\n  indicator: \"activeGateVersions\",\n  0: \"‚ö†Ô∏è Some ActiveGates are running an unsupported version. Update them when possible\",\n  0.5: \"üí° Some older ActiveGates should be updated to benefit from the latest features and performance\",\n  1: \"‚úÖ All deployed ActiveGates were recently updated\"\n}\n]\n\n// List indicators that can be evaluated in a tenant scope\nconst tenantIndicators = [\n  fullStackCoverage,\n  candidates,\n  hostGroups,\n  hostGroupCoverage,\n  uniqueProcessGroups,\n  declarativeProcessGroupings,\n  uniqueServices,\n  customServices,\n  osServices,\n  serviceKeyRequests,\n  calculatedServiceMetrics,\n  webApps,\n  androidApps,\n  iosApps,\n  userTagCoverage,\n  uscm,\n  syntheticMonitors,\n  managementZones,\n  autoTags,\n  manualTags,\n  alertingProfiles,\n  integrations,\n  integrationTypes,\n  metricEvents,\n  slos,\n  releaseIntegrations,\n  logMonitoring,\n  thirdPartyVulnerabilityAnalytics,\n  codeLevelVulnerabilityAnalytics,\n  runtimeApplicationProtection,\n  dashboards,\n  notebooks,\n  cloudIntegrations,\n  extensions,\n  extensionConfigurations,\n  networkZones,\n  ownershipTeams,\n  auditLogs,\n  oneAgentVersions,\n  activeGateVersions\n];\n\n// List indicators that can be evaluated in a management zone scope\nconst managementZoneIndicators = [\n  fullStackCoverage,\n  hostGroups,\n  hostGroupCoverage,\n  uniqueProcessGroups,\n  uniqueServices,\n  customServices,\n  serviceKeyRequests,\n  webApps,\n  androidApps,\n  iosApps,\n  syntheticMonitors,\n  oneAgentVersions\n];\n\n// Find below an async function that returns the local score (1, 0.5 or 0) for each indicator\nasync function fullStackCoverage() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"HOST\"),monitoringMode(\"FULL_STACK\")';\n  } else {\n    entitySelector = `type(\"HOST\"),monitoringMode(\"FULL_STACK\"),mzName(${scope})`;\n  }\n  let config = { from: \"now-1d\", entitySelector: entitySelector};\n  const fullStackHosts = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false)';\n  } else {\n    entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),mzName(${scope})`;\n  }\n  config = { from: \"now-1d\", entitySelector: entitySelector};\n  const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n  const fullStackCoverage = Math.round(fullStackHosts.totalCount/monitoredHosts.totalCount*100);\n  const score = fullStackCoverage === 100 ? 1 : (fullStackCoverage >= 80 ? 0.5 : 0);\n  return score;\n}\n\nasync function candidates() {\n  let config = { from: `now-1d`, entitySelector: 'type(\"HOST\"),isMonitoringCandidate(false)'};\n  const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n  config = { from: `now-1d`, entitySelector: 'type(\"HOST\"),isMonitoringCandidate(true)'};\n  const monitoringCandidates = await monitoredEntitiesClient.getEntities(config);\n  const score = monitoringCandidates.totalCount === 0 ? 1 : (monitoringCandidates.totalCount < 50 ? 0.5 : 0);\n  return score;\n}\n\nasync function hostGroups() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"HOST_GROUP\")';\n  } else {\n    entitySelector = `type(\"HOST_GROUP\"),toRelationships.isInstanceOf(type(\"HOST\"),mzName(${scope}))`;\n  }\n  let config = { from: `now-7d`, entitySelector: entitySelector};\n  const hostGroups = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const hostGroupAppRatio = hostGroups.totalCount/(webApps.totalCount + mobileApps.totalCount + customApps.totalCount);\n  const score = hostGroupAppRatio >= 1 ? 1 : (hostGroupAppRatio >= 0.8 ? 0.5 : 0);\n  return score;\n}\n\nasync function hostGroupCoverage() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false)';\n  } else {\n    entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),mzName(${scope})`;\n  }\n  let config = { from: `now-1d`, entitySelector: entitySelector};\n  const monitoredHosts = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"HOST\"),isMonitoringCandidate(false),fromRelationships.isInstanceOf(type(\"HOST_GROUP\"))';\n  } else {\n    entitySelector = `type(\"HOST\"),isMonitoringCandidate(false),fromRelationships.isInstanceOf(type(\"HOST_GROUP\")),mzName(${scope})`;\n  }\n  config = { from: `now-1d`, entitySelector: entitySelector};\n  const hostsWithHostGroup = await monitoredEntitiesClient.getEntities(config);\n  const hostGroupCoverage = Math.round(hostsWithHostGroup.totalCount/monitoredHosts.totalCount*100);\n  const score = hostGroupCoverage === 100 ? 1 : (hostGroupCoverage >= 80 ? 0.5 : 0);\n  return score;\n}\n\nasync function uniqueProcessGroups() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"PROCESS_GROUP\")';\n  } else {\n    entitySelector = `type(\"PROCESS_GROUP\"),mzName(${scope})`;\n  }\n  let config = { from: \"now-1d\", entitySelector: entitySelector, pageSize: 12000 };\n  let objects = await monitoredEntitiesClient.getEntities(config);\n  const processGroupsCount = objects.totalCount;\n  let processGroups = objects.entities;\n  while(objects.nextPageKey) {\n    config = { nextPageKey: objects.nextPageKey };\n    objects = await monitoredEntitiesClient.getEntities(config);\n    processGroups = [...processGroups, ...objects.entities];\n  }\n  const lookup = processGroups.reduce((a, e) => {\n    a[e.displayName] = ++a[e.displayName] || 0;\n    return a;\n  }, {});\n  const duplicates = processGroups.filter(e => lookup[e.displayName]);\n  const uniqueProcessGroupRatio = 100 - parseInt(duplicates.length / processGroupsCount * 100);\n  const score = uniqueProcessGroupRatio === 100 ? 1 : (uniqueProcessGroupRatio >= 95 ? 0.5 : 0);\n  return score;\n}\n\nasync function declarativeProcessGroupings() {\n  let config = { schemaIds: 'builtin:declarativegrouping'};\n  const declarativeGroupings = await settingsObjectsClient.getSettingsObjects(config);\n  config = { from: `now-1d`, entitySelector: 'type(\"PROCESS_GROUP\")'};\n  const processGroups = await monitoredEntitiesClient.getEntities(config);\n  const declarativeGroupingRatio = declarativeGroupings.totalCount / processGroups.totalCount;\n  const score = declarativeGroupingRatio > 0.0001 ? 1 : 0;\n  return score;\n}\n\nasync function uniqueServices() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"SERVICE\")';\n  } else {\n    entitySelector = `type(\"SERVICE\"),mzName(${scope})`;\n  }\n  let config = { from: \"now-1d\", entitySelector: entitySelector, pageSize: 12000 };\n  let objects = await monitoredEntitiesClient.getEntities(config);\n  const servicesCount = objects.totalCount;\n  let services = objects.entities;\n  while(objects.nextPageKey) {\n    config = { nextPageKey: objects.nextPageKey };\n    objects = await monitoredEntitiesClient.getEntities(config);\n    services = [...services, ...objects.entities];\n  }\n  const lookup = services.reduce((a, e) => {\n    a[e.displayName] = ++a[e.displayName] || 0;\n    return a;\n  }, {});\n  const duplicates = services.filter(e => lookup[e.displayName]);\n  const uniqueServiceRatio = 100 - parseInt(duplicates.length / servicesCount * 100);\n  const score = uniqueServiceRatio === 100 ? 1 : (uniqueServiceRatio >= 95 ? 0.5 : 0);\n  return score;\n}\n\nasync function customServices() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"SERVICE\")';\n  } else {\n    entitySelector = `type(\"SERVICE\"),mzName(${scope})`;\n  }\n  let config = { from: \"now-1d\", entitySelector: entitySelector};\n  const services = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"SERVICE\"),serviceType(\"CUSTOM_SERVICE\")';\n  } else {\n    entitySelector = `type(\"SERVICE\"),serviceType(\"CUSTOM_SERVICE\"),mzName(${scope})`;\n  }\n  config = { from: \"now-1d\", entitySelector: entitySelector};\n  const customServices = await monitoredEntitiesClient.getEntities(config);\n  const customServiceRatio = customServices.totalCount / services.totalCount;\n  const score = customServiceRatio > 0.01 ? 1 : (customServiceRatio >= 0.001 ? 0.5 : 0);\n  return score;\n}\n\nasync function osServices() {\n  let config = { schemaIds: 'builtin:os-services-monitoring'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  const osServicesAlertingRules = objects.items.filter(el => el.value.enabled);\n  const score = osServicesAlertingRules.length > 1 ? 1 : (osServicesAlertingRules.length === 1 ? 0.5 : 0);\n  return score;\n}\n\nasync function serviceKeyRequests() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"SERVICE_METHOD\"),fromRelationships.isServiceMethodOfService(type(\"SERVICE\"))';\n  } else {\n    entitySelector = `type(\"SERVICE_METHOD\"),fromRelationships.isServiceMethodOfService(type(\"SERVICE\")),mzName(${scope})`;\n  }\n  let config = { from: \"now-1d\", entitySelector: entitySelector};\n  let objects = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  const serviceKeyRequestRatio = objects.totalCount / monitoredApps;\n  const score = (serviceKeyRequestRatio >= 3) ? 1 : (serviceKeyRequestRatio >= 1 ? 0.5 : 0);\n  return score;\n}\n\nasync function calculatedServiceMetrics() {\n  let config = { acceptType: \"application/json; charset=utf-8\", text: \"calc:service\" };\n  let objects = await metricsClient.allMetrics(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  const scmRatio = objects.totalCount / monitoredApps;\n  const score = scmRatio >= 3 ? 1 : (scmRatio >= 1 ? 0.5 : 0);\n  return score;\n}\n\nasync function webApps() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  const config = { from: `now-7d`, entitySelector: entitySelector};\n  const objects = await monitoredEntitiesClient.getEntities(config);\n  const score = (objects.entities.some(el => el.displayName === \"My web application\") || objects.totalCount === 0) ? 0 : 1;\n  return score;\n}\n\nasync function androidApps() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  let config = { from: `now-7d`, entitySelector: entitySelector};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const apps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"ANDROID\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"ANDROID\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const androidApps = await monitoredEntitiesClient.getEntities(config);\n  const androidAppRatio = androidApps.totalCount / apps;\n  const score = androidAppRatio >= 0.05 ? 1 : 0;\n  return score;\n}\n\nasync function iosApps() {\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  let config = { from: `now-7d`, entitySelector: entitySelector};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const apps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"IOS\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mobileOsFamily(\"IOS\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const iosApps = await monitoredEntitiesClient.getEntities(config);\n  const iosAppRatio = iosApps.totalCount / apps;\n  const score = iosAppRatio >= 0.05 ? 1 : 0;\n  return score;\n}\n\nasync function userTagCoverage() {\n  // Get user tagged apps\n  let userTaggedApps = await rumUserSessionsClient.getUsqlResultAsTable({\n    query: \"SELECT application FROM useraction WHERE (usersession.userId IS NOT NULL) GROUP BY application LIMIT 500\",\n    startTimestamp: (Date.now() - 7*24*60*60*1000),\n    pageSize: 500\n  });\n  // Get all apps\n  let config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  // compute user tag coverage\n  const userTaggedAppCoverage = parseInt((userTaggedApps.values.length / monitoredApps)*100);      \n  // Compute local score based on above number\n  const score = userTaggedAppCoverage >= 95 ? 1 : (userTaggedAppCoverage >= 80 ? 0.5 : 0);\n  return score;\n}\n\nasync function uscm() {\n  let config = { acceptType: \"application/json; charset=utf-8\", text: \"uscm.\" };\n  let objects = await metricsClient.allMetrics(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  const uscmRatio = objects.totalCount / monitoredApps;\n  const score = uscmRatio >= 3 ? 1 : (uscmRatio >= 1 ? 0.5 : 0);\n  return score;\n}\n\nasync function syntheticMonitors() {\n  // List all synthetic monitors\n  let scope;\n  if($Scope[0] === \"Tenant\") {\n    scope = 'Tenant';\n  } else {\n    let mzList = \"\";\n    for(let i=0; i<$Scope.length; i++) {\n      mzList += i === 0 ? `\"${$Scope[i]}\"` : `,\"${$Scope[i]}\"`;\n    }\n    scope = mzList;\n  }\n  // Define entity selector based on the selected scope\n  let entitySelector;\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"SYNTHETIC_TEST\")';\n  } else {\n    entitySelector = `type(\"SYNTHETIC_TEST\"),mzName(${scope})`;\n  }\n  let config = { from: `now-7d`, entitySelector: entitySelector};\n  const objects = await monitoredEntitiesClient.getEntities(config);\n  // Count monitored apps\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"APPLICATION\")';\n  } else {\n    entitySelector = `type(\"APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"MOBILE_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"MOBILE_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  if(scope === \"Tenant\") {\n    entitySelector = 'type(\"CUSTOM_APPLICATION\")';\n  } else {\n    entitySelector = `type(\"CUSTOM_APPLICATION\"),mzName(${scope})`;\n  }\n  config = { from: `now-7d`, entitySelector: entitySelector};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  const syntheticRatio = objects.totalCount / monitoredApps;\n  const score = syntheticRatio >= 3 ? 1 : (syntheticRatio >= 1 ? 0.5 : 0);\n  return score;\n}\n\nasync function managementZones() {\n  let config = { schemaIds: 'builtin:management-zones'};\n  let mz = await settingsObjectsClient.getSettingsObjects(config);\n  config = { from: \"now-1d\", entitySelector: 'type(\"APPLICATION\")'};\n  const webApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-1d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n  const mobileApps = await monitoredEntitiesClient.getEntities(config);\n  config = { from: \"now-1d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n  const customApps = await monitoredEntitiesClient.getEntities(config);\n  const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n  config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")', fields: 'managementZones', pageSize: 500};\n  const objects = await monitoredEntitiesClient.getEntities(config);\n  const appsWithNoMz = objects.entities.filter(el => el.managementZones.length === 0);\n  const score = appsWithNoMz.length === 0 ? 1 : 0;\n  return score;\n}\n\nasync function autoTags() {\n  const config = { schemaIds: 'builtin:tags.auto-tagging'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 3 ? 0.5 : 0);\n  return score;\n}\n\nasync function manualTags() {\n  let allCustomTags = [];\n  let entityTypes = ['SYNTHETIC_TEST', 'APPLICATION', 'MOBILE_APPLICATION', 'CUSTOM_APPLICATION', 'SERVICE', 'PROCESS_GROUP', 'HOST'];\n  for(let entityType of entityTypes) {\n    let customTags = await monitoredEntitiesCustomTagsClient.getTags({ entitySelector: `type(\"${entityType}\")` });\n    customTags = customTags.tags.map(el => el.key);\n    allCustomTags = [...allCustomTags, ...customTags];\n  }\n  const score = allCustomTags.length < 50 ? 1 : 0;\n  return score;\n}\n\nasync function alertingProfiles() {\n  let config = { schemaIds: 'builtin:management-zones'};\n  const mz = await settingsObjectsClient.getSettingsObjects(config);\n  config = { schemaIds: 'builtin:alerting.profile'};\n  const alertingProfiles = await settingsObjectsClient.getSettingsObjects(config);\n  const score = alertingProfiles.totalCount >= mz.totalCount ? 1 : (alertingProfiles.totalCount >= 5 ? 0.5 : 0);\n  return score;\n}\n\nasync function integrations() {\n  let config = { schemaIds: 'builtin:problem.notifications'};\n  const integrations = await settingsObjectsClient.getSettingsObjects(config);\n  config = { schemaIds: 'builtin:alerting.profile'};\n  const alertingProfiles = await settingsObjectsClient.getSettingsObjects(config);\n  const score = integrations.totalCount >= alertingProfiles.totalCount * 1.5 ? 1 : (integrations.totalCount >= alertingProfiles.totalCount ? 0.5 : 0);\n  return score;\n}\n\nasync function integrationTypes() {\n  let config = { schemaIds: 'builtin:problem.notifications'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  let integrationTypes = [];\n  for(let object of objects.items) {\n    integrationTypes.push(object.value.type);\n  }\n  integrationTypes = integrationTypes.filter(onlyUnique);\n  const score = integrationTypes.length >= 5 ? 1 : (integrationTypes.length >= 2 ? 0.5 : 0);\n  return score;\n}\n\nasync function metricEvents() {\n  let config = { schemaIds: 'builtin:anomaly-detection.metric-events', pageSize: 500};\n  let objects = await settingsObjectsClient.getSettingsObjects(config);\n  let metricEvents = objects.items;\n  while(objects.nextPageKey) {\n    config = { nextPageKey: objects.nextPageKey };\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n    metricEvents = [...metricEvents, ...objects.items];\n  }\n  const enabledMetricEventCount = metricEvents.filter(el => el.value.enabled).length;\n  const score = enabledMetricEventCount >= 5 ? 1 : 0;\n  return score;\n}\n\nasync function slos() {\n  let objects;\n  const config = { schemaIds: 'builtin:monitoring.slo'};\n  try {\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n  } catch(e) {}\n  let enabledSlos = 0;\n  if(objects) {\n    for(let slo of objects.items) {\n      if(slo.value.enabled) enabledSlos++;\n    }\n  }\n  const score = enabledSlos >= 10 ? 1 : (enabledSlos > 0 ? 0.5 : 0);\n  return score;\n}\n\nasync function releaseIntegrations() {\n  let objects;\n  const config = { schemaIds: 'builtin:issue-tracking.integration'};\n  try {\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n  } catch(e) {}\n  let enabledIssueTrackingSystems = 0;\n  if(objects) {\n    for(let enabledIssueTrackingSystem of objects.items) {\n      if(enabledIssueTrackingSystem.value.enabled) enabledIssueTrackingSystems++;\n    }\n  }\n  const score = enabledIssueTrackingSystems >= 5 ? 1 : (enabledIssueTrackingSystems >= 2 ? 0.5 : 0);\n  return score;\n}\n\nasync function logMonitoring() {\n  const config = { schemaIds: 'builtin:logmonitoring.log-storage-settings'};\n  let objects = { items: [] };\n      try {\n        objects = await settingsObjectsClient.getSettingsObjects(config);  \n      } catch(e) {}\n  const logStorageIncludeRules = objects.items.filter(el => el.value.enabled).length;\n  const score = logStorageIncludeRules > 0 ? 1 : 0;\n  return score;\n}\n\nasync function thirdPartyVulnerabilityAnalytics() {\n  let objects;\n  const config = { schemaIds: 'builtin:appsec.runtime-vulnerability-detection'};\n  try {\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n  } catch(e) {}\n  const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enableRuntimeVulnerabilityDetection ? 1 : 0;\n  return score;\n}\n\nasync function codeLevelVulnerabilityAnalytics() {\n  let objects;\n  const config = { schemaIds: 'builtin:appsec.runtime-vulnerability-detection'};\n  try {\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n  } catch(e) {}\n  const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enableCodeLevelVulnerabilityDetection ? 1 : 0;\n  return score;\n}\n\nasync function runtimeApplicationProtection() {\n  let objects;\n  const config = { schemaIds: 'builtin:appsec.attack-protection-settings'};\n  try {\n    objects = await settingsObjectsClient.getSettingsObjects(config);\n  } catch(e) {}\n  const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enabled ? 1 : 0;\n  return score;\n}\n\nasync function dashboards() {\n  const config = { filter: \"type = 'dashboard'\"};\n  let objects = await documentsClient.listDocuments(config);\n  const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 5 ? 0.5 : 0);\n  return score;\n}\n\nasync function notebooks() {\n  const config = { filter: \"type = 'notebook'\"};\n  let objects = await documentsClient.listDocuments(config);\n  const score = objects.totalCount >= 10 ? 1 : (objects.totalCount >= 5 ? 0.5 : 0);\n  return score;\n}\n\nasync function cloudIntegrations() {\n  // Count cloud integrations\n  let config = { writtenSince: \"now-1d\", acceptType: \"application/json; charset=utf-8\", text: \"builtin:cloud\", pageSize: 500 };\n  let objects = await metricsClient.allMetrics(config);\n  let metrics = objects.metrics;\n  while(objects.nextPageKey) {\n    config = { acceptType: \"application/json; charset=utf-8\", nextPageKey: objects.nextPageKey };\n    objects = await metricsClient.allMetrics(config);\n    metrics = [...metrics, ...objects.metrics];\n  }\n  let cloudIntegrationCount = metrics.map(el => el.metricId.substring(\"builtin:cloud.\".length,(\"builtin:cloud.\".length + el.metricId.substring(\"builtin:cloud.\".length).indexOf(\".\")))).filter(onlyUnique).length;\n  // Count Kubernetes integrations\n  config = { from: \"now-1d\", entitySelector: `type(\"KUBERNETES_CLUSTER\")` };\n  objects = await monitoredEntitiesClient.getEntities(config);\n  if(objects.totalCount) cloudIntegrationCount++;\n  const score = cloudIntegrationCount >= 3 ? 1 : 0;\n  return score;\n}\n\nasync function extensions() {\n  const config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_count:last(avg)'};\n  const objects = await metricsClient.query(config);\n  const extensionCount = objects.result[0].data[0].values[0];\n  const score = extensionCount >= 10 ? 1 : (extensionCount > 0 ? 0.5 : 0);\n  return score;\n}\n\nasync function extensionConfigurations() {\n  let config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_monitoring_configuration_count:last(avg)'};\n  let objects = await metricsClient.query(config);\n  const extensionConfigCount = objects.result[0].data[0].values[0];\n  config = { acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:extension.extensions_count:last(avg)'};\n  objects = await metricsClient.query(config);\n  const extensionCount = objects.result[0].data[0].values[0];\n  const score = extensionConfigCount >= extensionCount * 1.5 ? 1 : (extensionConfigCount >= extensionCount ? 0.5 : 0);\n  return score;\n}\n\nasync function networkZones() {\n  const config = { schemaIds: 'builtin:networkzones'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  const score = objects.totalCount > 0 ? 1 : 0;\n  return score;\n}\n\nasync function ownershipTeams() {\n  let config = { schemaIds: 'builtin:ownership.teams'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  const score = objects.items.length >= 10 ? 1 : (objects.items.length >= 5 ? 0.5 : 0);\n  return score;\n}\n\nasync function auditLogs() {\n  const config = { schemaIds: 'builtin:audit-log'};\n  const objects = await settingsObjectsClient.getSettingsObjects(config);\n  const score = objects && objects.items[0] && objects.items[0].value && objects.items[0].value.enabled ? 1 : 0;\n  return score;\n}\n\nasync function oneAgentVersions() {\n  const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n  const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n  let config = { from: \"now-5m\", acceptType: \"application/json; charset=utf-8\", metricSelector: 'dsfm:cluster.oneagent.agent_modules:filter(and(or(eq(\"dt.oneagent.agent_type\",os)))):splitBy(\"dt.oneagent.version\"):sum:last():sort(value(sum,descending)):limit(100)'};\n  let objects = await metricsClient.query(config);\n  const oneAgentVersionStats = {\n    records: [],\n    types: [\n      {\n        mappings: {\n          oneAgentVersion: {\n            type: \"string\"\n          },\n          running: {\n            type: \"long\"\n          }\n        },\n        indexRange: [\n          0,\n          1\n        ]\n      }\n    ]\n  };\n  for(let oneAgentVersion of objects.result[0].data) {\n    const score = oneAgentVersion.dimensionMap['dt.oneagent.version'].substring(2) >= (latestVersion - 6) ? 1 : (oneAgentVersion.dimensionMap['dt.oneagent.version'].substring(2) >= oldestSupportedVersion ? 0.5 : 0);\n    let result = {};\n    switch(true) {\n      case score === 1:\n        result.oneAgentVersion = `‚úÖ ${oneAgentVersion.dimensionMap['dt.oneagent.version']}`;\n        break;\n      case score === 0.5:\n        result.oneAgentVersion = `üí° ${oneAgentVersion.dimensionMap['dt.oneagent.version']}`;\n        break;\n      case score === 0:\n        result.oneAgentVersion = `‚ö†Ô∏è ${oneAgentVersion.dimensionMap['dt.oneagent.version']}`;\n        break;\n    }\n    result.running = oneAgentVersion.values[0];\n    oneAgentVersionStats.records.push(result);\n  }\n  const score = oneAgentVersionStats.records.findIndex(el => el.oneAgentVersion.substring(4) < (latestVersion - 6)) === -1 ? 1 : (oneAgentVersionStats.records.findIndex(el => el.oneAgentVersion.substring(4) < oldestSupportedVersion) === -1 ? 0.5 : 0);\n  return score;\n}\n\nasync function activeGateVersions() {\n  const oldestSupportedVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 - 18;\n  const latestVersion = Math.round((Date.now()/1000 - 1363125600)/(60*60*24*7*2*2))*2 - 1 + 2;\n  const objects = await activeGatesClient.getAllActiveGates();\n  const names = objects.activeGates.map(el => {\n    const filteredEntry = {};\n    switch(true) {\n    case el.version.substring(2,5) < oldestSupportedVersion:\n      filteredEntry.Version = `‚ö†Ô∏è ${el.version}`;\n      break;\n    case el.version.substring(2,5) < (latestVersion - 6):\n      filteredEntry.Version = `üí° ${el.version}`;\n      break;\n    default:\n      filteredEntry.Version = `‚úÖ ${el.version}`;\n    }\n    filteredEntry.ActiveGate = el.hostname;\n    return filteredEntry;\n  });\n  const score = names.findIndex(el => el.Version.substring(4,7) < (latestVersion - 6)) === -1 ? 1 : (names.findIndex(el => el.Version.substring(4,7) < oldestSupportedVersion) === -1 ? 0.5 : 0);\n  return score;\n}\n\nexport default async function() {\n  const evaluations = [];\n  // Determine what indicators should be evaluated based on the selected DTR scope\n  let scopedIndicators;\n  if($Scope[0] === \"Tenant\") {\n    scopedIndicators = tenantIndicators;\n  } else {\n    scopedIndicators = managementZoneIndicators;\n  }\n  // Determine what indicators should be evaluated based on the selected indicators\n  let selectedIndicators = [];\n  if($Indicators[0] === \"All\") {\n    selectedIndicators = scopedIndicators;\n  } else {\n    for(let scopedIndicator of scopedIndicators) {\n      if($Indicators.includes(scopedIndicator.name)) {\n        selectedIndicators.push(scopedIndicator); \n      }\n    }\n  }\n  // Evaluate indicators\n  for(let selectedIndicator of selectedIndicators) {\n    const evaluation = await evaluate(selectedIndicator);\n    evaluations.push(evaluation);\n  }\n  // Filter out healthy indicators\n  const filteredEvaluations = evaluations.filter(e => e.score !== 1);\n  // Segment indicators per importance\n  const importantIndicatorEvaluations = filteredEvaluations.filter(e => e.weight === 1);\n  const bestPracticeIndicatorEvaluations = filteredEvaluations.filter(e => e.weight === 2);\n  const fundamentalIndicatorEvaluations = filteredEvaluations.filter(e => e.weight === 3);\n  // Sort each population per normalized score\n  const sortedImportantIndicatorEvaluations = sortArrayOfObjects(importantIndicatorEvaluations, \"score\");\n  const sortedBestPracticeIndicatorEvaluations = sortArrayOfObjects(bestPracticeIndicatorEvaluations, \"score\");\n  const sortedFundamentalIndicatorEvaluations = sortArrayOfObjects(fundamentalIndicatorEvaluations, \"score\");\n  // Concatenate groups of evaluations by order of importance\n  const finalEvaluations = sortedFundamentalIndicatorEvaluations;\n  finalEvaluations.push(...sortedBestPracticeIndicatorEvaluations);\n  finalEvaluations.push(...sortedImportantIndicatorEvaluations);\n  console.log(finalEvaluations);\n  // Extract the recommendation from each evaluation\n  const prioritizedRecommendations = finalEvaluations.map(e => {\n    return {\n      \"Prioritized next steps üëá\": e.recommendation,\n      \"Importance\": e.weight === 3 ? \"Fundamentals\" : (e.weight === 2 ? \"Best practice\" : \"Recommended\")\n    };\n  });\n  // Return prioritized recommendations\n  return prioritizedRecommendations.length > 0 ? prioritizedRecommendations : { \"Prioritized next steps üëá\": \"‚úÖ Well done! All recommendations have been implemented üëè\"};\n}","visualization":"table","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[["Prioritized next steps üëá"]]}}},"182":{"type":"markdown","title":"","content":" Full details:"},"183":{"type":"markdown","title":"","content":"#\n#### Unlock the maximum value from the Dynatrace platform.\n\n "},"184":{"type":"code","title":"","input":"import { monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\nimport { rumUserSessionsClient } from \"@dynatrace-sdk/client-classic-environment-v1\";\n\nexport default async function() {\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"userTagCoverage\")) {\n    if($Scope[0] === \"Tenant\") {\n      // Get user tagged apps\n      let userTaggedApps = await rumUserSessionsClient.getUsqlResultAsTable({\n        query: \"SELECT application FROM useraction WHERE (usersession.userId IS NOT NULL) GROUP BY application LIMIT 500\",\n        startTimestamp: (Date.now() - 7*24*60*60*1000),\n        pageSize: 500\n      });\n      // Get all apps\n      let config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n      const webApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n      const mobileApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n      const customApps = await monitoredEntitiesClient.getEntities(config);\n      const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n      // compute user tag coverage\n      const userTaggedAppCoverage = parseInt((userTaggedApps.values.length / monitoredApps)*100);      \n      // Compute local score based on above number\n      const score = userTaggedAppCoverage >= 95 ? 1 : (userTaggedAppCoverage >= 80 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ ${userTaggedAppCoverage}%`;\n          break;\n        case score === 0.5:\n          result = `üí° ${userTaggedAppCoverage}%`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è ${userTaggedAppCoverage}%`;\n          break;\n      }\n      return result;\n    } else {\n      return \"N/A\";\n    }\n  } else {\n    return \"N/A\";\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":true,"label":"User tag coverage","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}},"185":{"type":"code","title":"","input":"import { monitoredEntitiesClient  } from '@dynatrace-sdk/client-classic-environment-v2';\nimport { rumUserSessionsClient } from \"@dynatrace-sdk/client-classic-environment-v1\";\n\nexport default async function() {\n  if($Indicators[0] === \"All\" || $Indicators.includes(\"userTagCoverage\")) {\n    if($Scope[0] === \"Tenant\") {\n      // Get user tagged apps\n      let userTaggedApps = await rumUserSessionsClient.getUsqlResultAsTable({\n        query: \"SELECT application FROM useraction WHERE (usersession.userId IS NOT NULL) GROUP BY application LIMIT 500\",\n        startTimestamp: (Date.now() - 7*24*60*60*1000),\n        pageSize: 500\n      });\n      // Get all apps\n      let config = { from: \"now-7d\", entitySelector: 'type(\"APPLICATION\")'};\n      const webApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"MOBILE_APPLICATION\")'};\n      const mobileApps = await monitoredEntitiesClient.getEntities(config);\n      config = { from: \"now-7d\", entitySelector: 'type(\"CUSTOM_APPLICATION\")'};\n      const customApps = await monitoredEntitiesClient.getEntities(config);\n      const monitoredApps = webApps.totalCount + mobileApps.totalCount + customApps.totalCount;\n      // compute user tag coverage\n      const userTaggedAppCoverage = parseInt((userTaggedApps.values.length / monitoredApps)*100);      \n      // Compute local score based on above number\n      const score = userTaggedAppCoverage >= 95 ? 1 : (userTaggedAppCoverage >= 80 ? 0.5 : 0);\n      let result;\n      switch(true) {\n        case score === 1:\n          result = `‚úÖ You're leveraging user tagging`;\n          break;\n        case score === 0.5:\n          result = `üí° Define more user tag capturing rules to identify user sessions in a breeze`;\n          break;\n        case score === 0:\n          result = `‚ö†Ô∏è Define more user tag capturing rules to identify user sessions in a breeze`;\n          break;\n      }\n     // Return the emojied recommendation\n     return result;\n    } else {\n      return `Select the \"Tenant\" scope to review user session custom metrics`;\n    }\n  } else {\n    return `Select the \"uscm\" indicator to include it in the review`;\n  }\n}","visualization":"singleValue","visualizationSettings":{"chartSettings":{"gapPolicy":"connect"},"singleValue":{"showLabel":false,"label":"","autoscale":false},"table":{"enableLineWrap":true,"hiddenColumns":[],"lineWrapIds":[]}}}},"layouts":{"0":{"x":0,"y":8,"w":6,"h":6},"3":{"x":6,"y":14,"w":8,"h":4},"5":{"x":0,"y":16,"w":3,"h":2},"8":{"x":6,"y":8,"w":8,"h":6},"9":{"x":0,"y":19,"w":6,"h":6},"11":{"x":0,"y":18,"w":24,"h":1},"12":{"x":0,"y":28,"w":6,"h":6},"13":{"x":6,"y":28,"w":8,"h":6},"14":{"x":0,"y":27,"w":24,"h":1},"17":{"x":0,"y":38,"w":24,"h":1},"19":{"x":0,"y":45,"w":2,"h":2},"20":{"x":2,"y":45,"w":2,"h":2},"22":{"x":0,"y":49,"w":24,"h":1},"23":{"x":6,"y":57,"w":4,"h":6},"24":{"x":0,"y":57,"w":6,"h":6},"25":{"x":14,"y":8,"w":10,"h":6},"26":{"x":14,"y":19,"w":10,"h":6},"27":{"x":3,"y":25,"w":3,"h":2},"28":{"x":14,"y":28,"w":10,"h":5},"29":{"x":14,"y":39,"w":10,"h":5},"30":{"x":14,"y":50,"w":10,"h":5},"32":{"x":3,"y":14,"w":3,"h":2},"35":{"x":2,"y":34,"w":2,"h":2},"38":{"x":4,"y":45,"w":2,"h":2},"39":{"x":0,"y":39,"w":6,"h":6},"42":{"x":6,"y":39,"w":8,"h":10},"43":{"x":0,"y":14,"w":3,"h":2},"44":{"x":3,"y":16,"w":3,"h":2},"46":{"x":0,"y":50,"w":6,"h":6},"47":{"x":6,"y":50,"w":8,"h":6},"48":{"x":14,"y":57,"w":10,"h":5},"49":{"x":0,"y":56,"w":24,"h":1},"50":{"x":0,"y":64,"w":6,"h":6},"51":{"x":0,"y":72,"w":24,"h":1},"52":{"x":0,"y":63,"w":24,"h":1},"53":{"x":6,"y":68,"w":4,"h":4},"54":{"x":14,"y":64,"w":10,"h":6},"55":{"x":0,"y":73,"w":6,"h":6},"56":{"x":0,"y":79,"w":2,"h":2},"57":{"x":2,"y":79,"w":2,"h":2},"58":{"x":4,"y":79,"w":2,"h":2},"59":{"x":6,"y":73,"w":8,"h":4},"61":{"x":6,"y":77,"w":8,"h":4},"62":{"x":0,"y":81,"w":24,"h":1},"63":{"x":0,"y":88,"w":6,"h":2},"64":{"x":0,"y":82,"w":6,"h":6},"65":{"x":0,"y":98,"w":6,"h":2},"66":{"x":0,"y":100,"w":6,"h":2},"67":{"x":0,"y":102,"w":6,"h":2},"68":{"x":0,"y":90,"w":24,"h":1},"69":{"x":6,"y":82,"w":8,"h":8},"70":{"x":6,"y":98,"w":8,"h":6},"72":{"x":0,"y":36,"w":3,"h":2},"73":{"x":3,"y":36,"w":3,"h":2},"74":{"x":3,"y":47,"w":3,"h":2},"75":{"x":14,"y":73,"w":10,"h":4},"76":{"x":14,"y":82,"w":10,"h":6},"77":{"x":14,"y":98,"w":10,"h":3},"78":{"x":0,"y":91,"w":6,"h":6},"79":{"x":0,"y":104,"w":24,"h":1},"81":{"x":0,"y":97,"w":24,"h":1},"83":{"x":14,"y":91,"w":10,"h":5},"84":{"x":0,"y":105,"w":6,"h":3},"85":{"x":0,"y":108,"w":6,"h":3},"86":{"x":10,"y":105,"w":4,"h":3},"87":{"x":10,"y":111,"w":4,"h":3},"88":{"x":6,"y":34,"w":8,"h":4},"89":{"x":3,"y":126,"w":3,"h":2},"90":{"x":6,"y":115,"w":8,"h":6},"92":{"x":6,"y":122,"w":8,"h":6},"93":{"x":6,"y":108,"w":4,"h":3},"94":{"x":6,"y":111,"w":4,"h":3},"95":{"x":6,"y":105,"w":4,"h":3},"96":{"x":6,"y":129,"w":8,"h":6},"98":{"x":10,"y":57,"w":4,"h":6},"100":{"x":6,"y":64,"w":8,"h":4},"101":{"x":0,"y":111,"w":6,"h":3},"102":{"x":0,"y":70,"w":6,"h":2},"103":{"x":10,"y":68,"w":4,"h":4},"104":{"x":0,"y":114,"w":24,"h":1},"105":{"x":0,"y":115,"w":6,"h":6},"106":{"x":0,"y":121,"w":24,"h":1},"107":{"x":3,"y":133,"w":3,"h":2},"109":{"x":0,"y":128,"w":24,"h":1},"110":{"x":14,"y":115,"w":10,"h":6},"111":{"x":14,"y":122,"w":10,"h":5},"112":{"x":14,"y":129,"w":10,"h":5},"113":{"x":0,"y":126,"w":3,"h":2},"114":{"x":0,"y":133,"w":3,"h":2},"115":{"x":4,"y":34,"w":2,"h":2},"116":{"x":10,"y":108,"w":4,"h":3},"117":{"x":6,"y":19,"w":8,"h":8},"118":{"x":0,"y":25,"w":3,"h":2},"119":{"x":6,"y":91,"w":8,"h":6},"121":{"x":14,"y":14,"w":10,"h":1},"122":{"x":14,"y":15,"w":10,"h":1},"123":{"x":14,"y":16,"w":10,"h":1},"124":{"x":14,"y":17,"w":10,"h":1},"125":{"x":14,"y":25,"w":10,"h":1},"126":{"x":14,"y":33,"w":10,"h":1},"127":{"x":14,"y":26,"w":10,"h":1},"128":{"x":14,"y":36,"w":10,"h":1},"129":{"x":14,"y":34,"w":10,"h":1},"130":{"x":14,"y":35,"w":10,"h":1},"131":{"x":14,"y":37,"w":10,"h":1},"132":{"x":14,"y":44,"w":10,"h":1},"133":{"x":14,"y":45,"w":10,"h":1},"134":{"x":14,"y":47,"w":10,"h":1},"135":{"x":14,"y":48,"w":10,"h":1},"136":{"x":14,"y":55,"w":10,"h":1},"137":{"x":14,"y":62,"w":10,"h":1},"138":{"x":14,"y":70,"w":10,"h":1},"139":{"x":14,"y":71,"w":10,"h":1},"140":{"x":14,"y":78,"w":10,"h":1},"141":{"x":14,"y":79,"w":10,"h":1},"142":{"x":14,"y":77,"w":10,"h":1},"143":{"x":14,"y":80,"w":10,"h":1},"144":{"x":14,"y":88,"w":10,"h":1},"145":{"x":14,"y":89,"w":10,"h":1},"146":{"x":14,"y":96,"w":10,"h":1},"147":{"x":14,"y":101,"w":10,"h":1},"148":{"x":14,"y":102,"w":10,"h":1},"149":{"x":14,"y":103,"w":10,"h":1},"150":{"x":14,"y":107,"w":10,"h":1},"151":{"x":14,"y":105,"w":10,"h":1},"152":{"x":14,"y":106,"w":10,"h":1},"153":{"x":14,"y":109,"w":10,"h":1},"154":{"x":14,"y":110,"w":10,"h":1},"155":{"x":14,"y":108,"w":10,"h":1},"156":{"x":14,"y":111,"w":10,"h":1},"157":{"x":14,"y":112,"w":10,"h":1},"158":{"x":14,"y":127,"w":10,"h":1},"159":{"x":14,"y":134,"w":10,"h":1},"160":{"x":3,"y":3,"w":3,"h":4},"161":{"x":0,"y":2,"w":24,"h":1},"162":{"x":0,"y":0,"w":6,"h":2},"163":{"x":0,"y":3,"w":3,"h":4},"164":{"x":0,"y":135,"w":24,"h":1},"165":{"x":6,"y":136,"w":8,"h":3},"168":{"x":0,"y":122,"w":6,"h":2},"171":{"x":0,"y":124,"w":3,"h":2},"172":{"x":3,"y":124,"w":3,"h":2},"173":{"x":0,"y":129,"w":6,"h":2},"175":{"x":3,"y":131,"w":3,"h":2},"176":{"x":0,"y":131,"w":3,"h":2},"177":{"x":0,"y":34,"w":2,"h":2},"178":{"x":14,"y":136,"w":10,"h":3},"179":{"x":0,"y":136,"w":6,"h":3},"180":{"x":6,"y":3,"w":8,"h":4},"182":{"x":0,"y":7,"w":24,"h":1},"183":{"x":6,"y":0,"w":18,"h":2},"184":{"x":0,"y":47,"w":3,"h":2},"185":{"x":14,"y":46,"w":10,"h":1}}}

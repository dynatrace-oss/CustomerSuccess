{"version":19,"variables":[{"version":2,"key":"SupportOverrides","type":"code","visible":true,"editable":true,"input":"export default async function () {\n  /*\n  * Update the overrides constant below with your own support extensions or end of life documentation\n  * Add 'ESS': true if you contracted Dynatrace Enterprise Success and Support which includes OneAgent and ActiveGate extended support. If omitted, defaults to false.\n  * For operating systems, use the Full Name as key and define the extended support date (YYYY-MM-DD) as value.\n  * For technologies, use the : concatenation of Technology, Edition and Version as key. Edition can be null. And define the extended support date (YYYY-MM-DD) as value.\n  * Libraries most often have no proper end of life, except when they become affected by a vulnerability. Thus, it's not permitted to define overrides for libraries.\n  * You can review below a few commented examples of support extension definition\n  */\n  const overrides = {\n    'N/A': 'Edit this variable to define support overrides (for filling gaps or enforcing custom extended support dates', // Comment this line once you defined other support overrides\n    // 'ESS': true,\n    // 'Linux - Debian GNU/Linux 10 (buster) (kernel 5.10.233-224.894.amzn2.x86_64)': '2026-09-10',\n    // 'Debian GNU/Linux 12 (bookworm) (kernel 6.1.0-25-cloud-amd64)': '2026-10-30',\n    // 'Ubuntu 18.04.6 LTS (Bionic Beaver) (kernel 5.4.0-1089-azure)': '2026-10-30',\n    // 'Container-Optimized OS 113 (kernel 6.1.123+)': '2025-10-30',\n    // 'Amazon Linux 2 (kernel 5.10.197-186.748.amzn2.x86_64)': '2025-04-30',\n    // 'MONGODB_CLIENT:driver-core-only:3.2.2': '2025-10-30',\n    // 'ASP_DOTNET_CORE:null:6.0.2623.60506': '2025-10-30',\n    // 'LIBC:glibc:2.31': '2025-10-30',\n  };\n  /*\n  * Only modify the code section below if you know what you're doing.\n  * It is essentially converting the above object into a JSON string compatible with \n  * dashboard variables' format\n  */\n  const overridesVariableArray = [];\n  for(let override of Object.keys(overrides)) {\n    const overridesVariable = {};\n    overridesVariable[override] = overrides[override];\n    overridesVariableArray.push(JSON.stringify(overridesVariable));\n  }\n  console.log(overridesVariableArray);\n  return overridesVariableArray;\n}","multiple":true,"defaultValue":["3420b2ac-f1cf-4b24-b62d-61ba1ba8ed05*"]},{"version":2,"key":"Coverage","type":"csv","visible":true,"editable":true,"input":"Operating Systems,Technologies,Libraries","multiple":true,"defaultValue":["3420b2ac-f1cf-4b24-b62d-61ba1ba8ed05*"]},{"version":2,"key":"Status","type":"csv","visible":true,"editable":true,"input":"üü¢ Up-to-date,üü° Updatable,üü† Obsolete,üî¥ Vulnerable,‚ö™ Undocumented,‚ö†Ô∏è Missing OneAgent","multiple":true,"defaultValue":["üü¢ Up-to-date","üü° Updatable","üü† Obsolete","üî¥ Vulnerable","‚ö†Ô∏è Missing OneAgent"]},{"version":2,"key":"MZ","type":"code","visible":true,"editable":true,"input":"import { settingsObjectsClient } from \"@dynatrace-sdk/client-classic-environment-v2\";\n\nexport default async function () {\n  let data =\n    await settingsObjectsClient.getSettingsObjects({\n      schemaIds: \"builtin:management-zones\",\n      scopes: \"environment\",\n      pageSize:500\n    });\n  \n  let arr = []; \n  \n  let l = data[\"items\"]\n  for(let i = 0; i < l.length; i++) {\n    let obj = l[i];\n    console.log(obj.value.name);\n    arr.push(obj[\"value\"][\"name\"]);\n  }\n  \n  while (data.hasOwnProperty('nextPageKey')) {\n    data = await settingsObjectsClient.getSettingsObjects({\n            nextPageKey: data[\"nextPageKey\"]\n    });\n    let d = data[\"items\"]\n    for(let i = 0; i < d.length; i++) {\n      let obj = d[i];\n      console.log(obj.value.name);\n      arr.push(obj[\"value\"][\"name\"]);\n    }  \n  }\n\n  return [\"Any\", ...arr.sort()];\n}","multiple":false,"defaultValue":"Any"},{"version":2,"key":"Tag","type":"code","visible":true,"editable":true,"input":"import { queryExecutionClient } from \"@dynatrace-sdk/client-query\";\n\nexport default async function() {\n  const objects = await queryExecutionClient.queryExecute({\n    body: {\n      query: 'fetch dt.entity.host, from: -15m | filter isNotNull(osVersion) | fieldsAdd tags | expand tags | filter isNotNull(tags) | summarize by:{tags}, count() | fields tags',\n      requestTimeoutMilliseconds: 10000,\n      maxResultRecords: 100000\n    },\n  });\n  return ['Any', ...objects.result.records.map(e => e.tags)];\n}","multiple":false,"defaultValue":"Any"},{"key":"OperatingSystems","visible":true,"type":"query","version":2,"editable":true,"input":"// This DQL query returns the Operating Systems which the obsolescence data has been retrieved for in the past 7 days:\nfetch events, from: -7d\n| filter dt.system.bucket == \"default_davis_custom_events\"\n| filter event.name == \"software-obsolescence-management.os-info\"\n| dedup os\n| fields os\n| append [data record(os = \"null\")]","multiple":true,"defaultValue":["3420b2ac-f1cf-4b24-b62d-61ba1ba8ed05*"]},{"key":"Technologies","visible":true,"type":"query","version":2,"editable":true,"input":"// This DQL query returns the Technologies which the obsolescence data has been retrieved for in the past 7 days:\nfetch events, from: -7d\n| filter dt.system.bucket == \"default_davis_custom_events\"\n| filter event.name == \"software-obsolescence-management.technology-info\"\n| dedup technology\n| fields technology\n| filter technology != \"DYNATRACE\"\n| append [data record(os = \"null\")]","multiple":true,"defaultValue":["3420b2ac-f1cf-4b24-b62d-61ba1ba8ed05*"]},{"key":"Libraries","visible":true,"type":"query","version":2,"editable":true,"input":"// This DQL query returns the Libraries which the obsolescence data has been retrieved for in the past 7 days:\nfetch events, from: -7d\n| filter dt.system.bucket == \"default_davis_custom_events\"\n| filter event.name == \"software-obsolescence-management.library-info\"\n| dedup library\n| fields library\n| append [data record(os = \"null\")]\n| limit 100000","multiple":true,"defaultValue":["3420b2ac-f1cf-4b24-b62d-61ba1ba8ed05*"]}],"tiles":{"120":{"type":"markdown","content":"#\n#### üíø Stay Ahead Of Your Software Portfolio üíø\n\n "},"121":{"title":"","type":"code","input":"export default async function() {\n  return 'Software Obsolescence Management';\n}","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"element","recordField":"element","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"122":{"type":"markdown","content":"# "},"123":{"title":"","type":"code","input":"export default async function() {\n  return 'Operating Systems';\n}","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"element","recordField":"element","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"124":{"title":"OS Version Distribution","type":"data","query":"fetch dt.entity.host, from: -15m\n| fieldsAdd osVersion, managementZones, hostGroupName, tags, softwareObsolescenceManagement = entity.name\n| filter isNotNull(osVersion) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Operating Systems\", $Coverage)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.os-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:osVersion,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd stringifiedOs = if(isNull(event.os), \"null\", else: event.os)\n| filter in(\"null\", $OperatingSystems) OR in(stringifiedOs, $OperatingSystems)\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), osVersion, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), osVersion, from: 0) +\n        stringLength(osVersion) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(timeBeforeObsolescence), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| fields Status, Host = entity.name, `Host Group` = hostGroupName, `Management Zones` = managementZones, `Tags` = tags, OS = event.os, `Running Version` = event.currentVersion, `Full Name` = osVersion, LTS = event.lts, Cycle = event.currentCycle, `Cycle Published At` = substring(event.currentCyclePublishedAt, to:10), `End of Life` = event.eol, `Extended Support`, `Max Age` = age, `Time Before Obsolescence` = timeBeforeObsolescence, `Latest Version` = event.latestVersion, `Published at` = substring(event.latestVersionPublishedAt, to:10), Link = event.link, id\n| append [ // VMWare\n  //from classic integration\n  fetch dt.entity.virtualmachine, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host], ipAddress, cloudTags=tags, datacenterId=belongs_to[dt.entity.vmware_datacenter]\n  //match with OneAgent hosts\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | lookup [fetch dt.entity.vmware_datacenter], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n    ipAddress = if(monitored, host.ipAddress, else:ipAddress), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"),\n    tags=arrayConcat(host.tags,cloudTags), datacenter=datacenter.entity.name, datacenter.id=datacenterId\n  //add extension VMs\n  | append [ fetch `dt.entity.vmware:virtualmachine`\n    | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n    | fieldsAdd host=arrayFirst(same_as[dt.entity.host]), ipAddress=vm_ip_address, cloudTags=array()\n    | lookup [fetch dt.entity.host | fieldsadd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\" //match with OneAgent hosts\n    | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n    | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n      ipAddress = if(monitored, host.ipAddress, else:ipAddress), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(host.tags,cloudTags)]\n  //add OneAgent VMware hosts\n  | append [ fetch dt.entity.host\n    | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n    | filter isNotNull(monitoringMode) AND hypervisorType == \"VMWARE\" AND isNull(runs_on[dt.entity.virtualmachine])\n    | fieldsAdd datacenterId=belongs_to[dt.entity.geoloc_site]\n    | lookup [fetch dt.entity.geoloc_site], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\", tags, datacenter=datacenter.entity.name, datacenter.id=datacenterId]\n  | dedup id\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown VMWare VM OS\", id\n]\n| append [ // AWS\n  fetch dt.entity.ec2_instance, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host], ipAddress=arrayConcat(if(isNotNull(localIp), array(localIp), else: array()), if(isNotNull(publicIp), array(publicIp), else: array())),\n    cloudMonitored=isNotNull(accessible_by[dt.entity.aws_credentials]), cloudTags=tags, datacenterId=belongs_to[dt.entity.aws_availability_zone]\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | lookup [fetch dt.entity.aws_availability_zone], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n  | fieldsAdd oneAgentMonitored=not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(oneAgentMonitored, host.id, else:id), entity.name=if(oneAgentMonitored, host.entity.name, else:entity.name),\n    ipAddress=if(oneAgentMonitored, host.ipAddress, else:ipAddress), monitoringStatus=if(oneAgentMonitored AND cloudMonitored,\"FULL\", else:if(oneAgentMonitored, \"OA\", else:\"CLOUD\")),\n    tags=arrayConcat(host.tags,cloudTags), datacenter=datacenter.entity.name, datacenter.id=datacenterId\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown AWS VM OS\", id\n]\n| append [ // GCP\n  fetch `dt.entity.cloud:gcp:gce_instance`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host][0], cloudTags=tags, zone\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], lookupField: id, sourceField:host, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"),\n    tags=arrayConcat(cloudTags,host.tags), datacenter=zone\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND cloudType == \"GOOGLE_CLOUD_PLATFORM\" AND isNull(runs_on[`dt.entity.cloud:gcp:gce_instance`])\n    | fieldsAdd datacenterId=belongs_to[dt.entity.gcp_zone]\n    | lookup [fetch dt.entity.gcp_zone], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n    | fields id, entity.name, ipAddress, monitoringStatus=\"OA\", tags, datacenter=datacenter.entity.name, datacenter.id=datacenterId]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown GCP VM OS\", id\n]\n| append [ // Azure\n  fetch dt.entity.azure_vm, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host], ipAddress, cloudMonitored=isNotNull(accessible_by[dt.entity.azure_subscription]),\n    cloudTags=tags, datacenterId=belongs_to[dt.entity.azure_region]\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | lookup [fetch dt.entity.azure_region], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n  | fieldsAdd oneAgentMonitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(oneAgentMonitored, host.id, else:id), entity.name=if(oneAgentMonitored, host.entity.name, else:entity.name),\n    ipAddress = if(oneAgentMonitored, host.ipAddress, else:ipAddress), monitoringStatus=if(oneAgentMonitored AND cloudMonitored, \"FULL\", else: if(oneAgentMonitored, \"OA\", else: \"CLOUD\")),\n    tags=arrayConcat(host.tags,cloudTags), datacenter=datacenter.entity.name, datacenter.id=datacenterId\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Azure VM OS\", id\n]\n| append [ // Hyper-V\n  fetch `dt.entity.hyperv:virtual_machine`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=same_as[dt.entity.host][0], ip_address, cloudTags=tags\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n    ipAddress = if(monitored, host.ipAddress, else:ip_address), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(host.tags,cloudTags)\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND hypervisorType == \"HYPER_V\" AND cloudType != \"AZURE\" AND isNull(same_as[`dt.entity.hyperv:virtual_machine`])\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\", tags]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Hyper-V VM OS\", id\n]\n| append [ // Nutanix\n  fetch `dt.entity.nutanix:vm`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=same_as[dt.entity.host][0], IpAddress, cloudTags=tags\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n    ipAddress = if(monitored, host.ipAddress, else:IpAddress), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(host.tags,cloudTags)\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND hypervisorType == \"AHV\" AND isNull(same_as[`dt.entity.nutanix:vm`])\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\", tags]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Nutanix VM OS\", id\n]\n| append [ // Oracle\n  fetch `dt.entity.cloud:oci:compute`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host][0], cloudTags=tags\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], lookupField: id, sourceField:host, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(cloudTags,host.tags)\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND cloudType == \"ORACLE\" AND isNull(runs_on[`dt.entity.cloud:oci:compute`])\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\",tags]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Oracle VM OS\", id\n]\n| summarize by:{Status, `Full Name`, `Time Before Obsolescence`}, count = count()\n| fields Status, `Host Count` = count, `Time Before Obsolescence`, `Full Name`\n| sort `Time Before Obsolescence` ASC, `Host Count` DESC","visualization":"table","visualizationSettings":{"table":{"columnWidths":{"[\"OS\"]":171.9479217529297,"[\"Status\"]":154.61459350585938}},"autoSelectVisualization":false,"thresholds":[]},"querySettings":{"maxResultRecords":100000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":100,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"125":{"title":"Operating Systems","type":"data","query":"fetch dt.entity.host, from: -15m\n| fieldsAdd osVersion, managementZones, hostGroupName, tags, softwareObsolescenceManagement = entity.name\n| filter isNotNull(osVersion) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Operating Systems\", $Coverage)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.os-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:osVersion,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd stringifiedOs = if(isNull(event.os), \"null\", else: event.os)\n| filter in(\"null\", $OperatingSystems) OR in(stringifiedOs, $OperatingSystems)\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), osVersion, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), osVersion, from: 0) +\n        stringLength(osVersion) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(timeBeforeObsolescence), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| fields Status, Host = entity.name, `Host Group` = hostGroupName, `Management Zones` = managementZones, `Tags` = tags, OS = event.os, `Running Version` = event.currentVersion, `Full Name` = osVersion, LTS = event.lts, Cycle = event.currentCycle, `Cycle Published At` = substring(event.currentCyclePublishedAt, to:10), `End of Life` = event.eol, `Max Age` = age, `Time Before Obsolescence` = timeBeforeObsolescence, `Latest Version` = event.latestVersion, `Published at` = substring(event.latestVersionPublishedAt, to:10), Link = event.link, id\n| filter isNotNull(OS)\n| summarize countDistinct(OS)","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"countDistinct(osVersion)","recordField":"countDistinct(OS)","prefixIcon":"","trend":{"isVisible":true}},"autoSelectVisualization":false,"thresholds":[],"unitsOverrides":[{"identifier":"countDistinct(OS)","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1740152434688}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"126":{"title":"Hosts with Obsolete OS Version","type":"data","query":"fetch dt.entity.host, from: -15m\n| fieldsAdd osVersion, managementZones, hostGroupName, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü† Obsolete\", $Status) AND isNotNull(osVersion) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Operating Systems\", $Coverage)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.os-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:osVersion,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd stringifiedOs = if(isNull(event.os), \"null\", else: event.os)\n| filter in(\"null\", $OperatingSystems) OR in(stringifiedOs, $OperatingSystems)\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), osVersion, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), osVersion, from: 0) +\n        stringLength(osVersion) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(timeBeforeObsolescence), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü† Obsolete\")\n| summarize count = count()\n| fields concat(count, \"üü†\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü†\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"127":{"title":"Hosts with Updatable OS Version","type":"data","query":"fetch dt.entity.host, from: -15m\n| fieldsAdd osVersion, managementZones, hostGroupName, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü° Updatable\", $Status) AND isNotNull(osVersion) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Operating Systems\", $Coverage)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.os-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:osVersion,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd stringifiedOs = if(isNull(event.os), \"null\", else: event.os)\n| filter in(\"null\", $OperatingSystems) OR in(stringifiedOs, $OperatingSystems)\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), osVersion, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), osVersion, from: 0) +\n        stringLength(osVersion) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(timeBeforeObsolescence), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü° Updatable\")\n| summarize count = count()\n| fields concat(count, \"üü°\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü°\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"128":{"title":"Unique Versions","type":"data","query":"fetch dt.entity.host, from: -15m\n| fieldsAdd osVersion, managementZones, hostGroupName, tags, softwareObsolescenceManagement = entity.name\n| filter isNotNull(osVersion) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Operating Systems\", $Coverage)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.os-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:osVersion,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd stringifiedOs = if(isNull(event.os), \"null\", else: event.os)\n| filter in(\"null\", $OperatingSystems) OR in(stringifiedOs, $OperatingSystems)\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), osVersion, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), osVersion, from: 0) +\n        stringLength(osVersion) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(timeBeforeObsolescence), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| fields Status, Host = entity.name, `Host Group` = hostGroupName, `Management Zones` = managementZones, `Tags` = tags, OS = event.os, `Running Version` = event.currentVersion, `Full Name` = osVersion, LTS = event.lts, Cycle = event.currentCycle, `Cycle Published At` = substring(event.currentCyclePublishedAt, to:10), `End of Life` = event.eol, `Max Age` = age, `Time Before Obsolescence` = timeBeforeObsolescence, `Latest Version` = event.latestVersion, `Published at` = substring(event.latestVersionPublishedAt, to:10), Link = event.link, id\n| filter isNotNull(OS)\n| summarize countDistinct(`Full Name`)","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"countDistinct(osVersion)","recordField":"countDistinct(`Full Name`)","prefixIcon":"","trend":{"isVisible":true}},"autoSelectVisualization":false,"thresholds":[],"unitsOverrides":[{"identifier":"countDistinct(`Full Name`)","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1740152448512}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"129":{"title":"Hosts with Up-To-Date OS Version","type":"data","query":"fetch dt.entity.host, from: -15m\n| fieldsAdd osVersion, managementZones, hostGroupName, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü¢ Up-to-date\", $Status) AND isNotNull(osVersion) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Operating Systems\", $Coverage)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.os-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:osVersion,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd stringifiedOs = if(isNull(event.os), \"null\", else: event.os)\n| filter in(\"null\", $OperatingSystems) OR in(stringifiedOs, $OperatingSystems)\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), osVersion, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), osVersion, from: 0) +\n        stringLength(osVersion) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(timeBeforeObsolescence), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü¢ Up-to-date\")\n| summarize count = count()\n| fields concat(count, \"üü¢\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü¢\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"130":{"title":"Hosts with Undocumented OS Version","type":"data","query":"fetch dt.entity.host, from: -15m\n| fieldsAdd osVersion, managementZones, hostGroupName, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"‚ö™ Undocumented\", $Status) AND isNotNull(osVersion) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Operating Systems\", $Coverage)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.os-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:osVersion,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd stringifiedOs = if(isNull(event.os), \"null\", else: event.os)\n| filter in(\"null\", $OperatingSystems) OR in(stringifiedOs, $OperatingSystems)\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), osVersion, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), osVersion, from: 0) +\n        stringLength(osVersion) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(timeBeforeObsolescence), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"‚ö™ Undocumented\")\n| summarize count = count()\n| fields concat(count, \"‚ö™\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"‚ö™\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"131":{"title":"Hosts with OneAgent","type":"data","query":"fetch dt.entity.host, from: -15m\n| fieldsAdd osVersion, managementZones, hostGroupName, tags, softwareObsolescenceManagement = entity.name\n| filter isNotNull(osVersion) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Operating Systems\", $Coverage)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.os-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:osVersion,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd stringifiedOs = if(isNull(event.os), \"null\", else: event.os)\n| filter in(\"null\", $OperatingSystems) OR in(stringifiedOs, $OperatingSystems)\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), osVersion, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), osVersion, from: 0) +\n        stringLength(osVersion) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(timeBeforeObsolescence), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| fields Status, Host = entity.name, `Host Group` = hostGroupName, `Management Zones` = managementZones, `Tags` = tags, OS = event.os, `Running Version` = event.currentVersion, `Full Name` = osVersion, LTS = event.lts, Cycle = event.currentCycle, `Cycle Published At` = substring(event.currentCyclePublishedAt, to:10), `End of Life` = event.eol, `Max Age` = age, `Time Before Obsolescence` = timeBeforeObsolescence, `Latest Version` = event.latestVersion, `Published at` = substring(event.latestVersionPublishedAt, to:10), Link = event.link, id\n| summarize count()","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"Status","recordField":"count()","prefixIcon":"","trend":{"isVisible":true}},"autoSelectVisualization":false,"thresholds":[],"unitsOverrides":[{"identifier":"count()","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1740152457563}]},"querySettings":{"maxResultRecords":100000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":100,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}},"segments":{"tileSegments":[],"tileSegmentsEnabled":false}},"132":{"title":"Hosts missing OneAgent","type":"data","query":"// VMWare\n//from classic integration\nfetch dt.entity.virtualmachine, from: -15m\n| filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n| fieldsAdd host=runs[dt.entity.host], ipAddress, cloudTags=tags, datacenterId=belongs_to[dt.entity.vmware_datacenter], softwareObsolescenceManagement = entity.name\n//match with OneAgent hosts\n| lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n| fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n| lookup [fetch dt.entity.vmware_datacenter], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n| fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n  ipAddress = if(monitored, host.ipAddress, else:ipAddress), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"),\n  tags=arrayConcat(host.tags,cloudTags), datacenter=datacenter.entity.name, datacenter.id=datacenterId\n//add extension VMs\n| append [ fetch `dt.entity.vmware:virtualmachine`\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=arrayFirst(same_as[dt.entity.host]), ipAddress=vm_ip_address, cloudTags=array()\n  | lookup [fetch dt.entity.host | fieldsadd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\" //match with OneAgent hosts\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n    ipAddress = if(monitored, host.ipAddress, else:ipAddress), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(host.tags,cloudTags)]\n//add OneAgent VMware hosts\n| append [ fetch dt.entity.host\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | filter isNotNull(monitoringMode) AND hypervisorType == \"VMWARE\" AND isNull(runs_on[dt.entity.virtualmachine])\n  | fieldsAdd datacenterId=belongs_to[dt.entity.geoloc_site]\n  | lookup [fetch dt.entity.geoloc_site], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n  | fields id,entity.name,ipAddress,monitoringStatus=\"OA\", tags, datacenter=datacenter.entity.name, datacenter.id=datacenterId]\n| dedup id\n| filter matchesValue(monitoringStatus, \"CLOUD\")\n| fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown VMWare VM OS\", id\n| append [ // AWS\n  fetch dt.entity.ec2_instance, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host], ipAddress=arrayConcat(if(isNotNull(localIp), array(localIp), else: array()), if(isNotNull(publicIp), array(publicIp), else: array())),\n    cloudMonitored=isNotNull(accessible_by[dt.entity.aws_credentials]), cloudTags=tags, datacenterId=belongs_to[dt.entity.aws_availability_zone]\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | lookup [fetch dt.entity.aws_availability_zone], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n  | fieldsAdd oneAgentMonitored=not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(oneAgentMonitored, host.id, else:id), entity.name=if(oneAgentMonitored, host.entity.name, else:entity.name),\n    ipAddress=if(oneAgentMonitored, host.ipAddress, else:ipAddress), monitoringStatus=if(oneAgentMonitored AND cloudMonitored,\"FULL\", else:if(oneAgentMonitored, \"OA\", else:\"CLOUD\")),\n    tags=arrayConcat(host.tags,cloudTags), datacenter=datacenter.entity.name, datacenter.id=datacenterId\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown AWS VM OS\", id\n]\n| append [ // GCP\n  fetch `dt.entity.cloud:gcp:gce_instance`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host][0], cloudTags=tags, zone\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], lookupField: id, sourceField:host, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"),\n    tags=arrayConcat(cloudTags,host.tags), datacenter=zone\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND cloudType == \"GOOGLE_CLOUD_PLATFORM\" AND isNull(runs_on[`dt.entity.cloud:gcp:gce_instance`])\n    | fieldsAdd datacenterId=belongs_to[dt.entity.gcp_zone]\n    | lookup [fetch dt.entity.gcp_zone], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n    | fields id, entity.name, ipAddress, monitoringStatus=\"OA\", tags, datacenter=datacenter.entity.name, datacenter.id=datacenterId]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown GCP VM OS\", id\n]\n| append [ // Azure\n  fetch dt.entity.azure_vm, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host], ipAddress, cloudMonitored=isNotNull(accessible_by[dt.entity.azure_subscription]),\n    cloudTags=tags, datacenterId=belongs_to[dt.entity.azure_region]\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | lookup [fetch dt.entity.azure_region], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n  | fieldsAdd oneAgentMonitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(oneAgentMonitored, host.id, else:id), entity.name=if(oneAgentMonitored, host.entity.name, else:entity.name),\n    ipAddress = if(oneAgentMonitored, host.ipAddress, else:ipAddress), monitoringStatus=if(oneAgentMonitored AND cloudMonitored, \"FULL\", else: if(oneAgentMonitored, \"OA\", else: \"CLOUD\")),\n    tags=arrayConcat(host.tags,cloudTags), datacenter=datacenter.entity.name, datacenter.id=datacenterId\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Azure VM OS\", id\n]\n| append [ // Hyper-V\n  fetch `dt.entity.hyperv:virtual_machine`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=same_as[dt.entity.host][0], ip_address, cloudTags=tags\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n    ipAddress = if(monitored, host.ipAddress, else:ip_address), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(host.tags,cloudTags)\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND hypervisorType == \"HYPER_V\" AND cloudType != \"AZURE\" AND isNull(same_as[`dt.entity.hyperv:virtual_machine`])\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\", tags]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Hyper-V VM OS\", id\n]\n| append [ // Nutanix\n  fetch `dt.entity.nutanix:vm`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=same_as[dt.entity.host][0], IpAddress, cloudTags=tags\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n    ipAddress = if(monitored, host.ipAddress, else:IpAddress), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(host.tags,cloudTags)\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND hypervisorType == \"AHV\" AND isNull(same_as[`dt.entity.nutanix:vm`])\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\", tags]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Nutanix VM OS\", id\n]\n| append [ // Oracle\n  fetch `dt.entity.cloud:oci:compute`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host][0], cloudTags=tags\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], lookupField: id, sourceField:host, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(cloudTags,host.tags)\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND cloudType == \"ORACLE\" AND isNull(runs_on[`dt.entity.cloud:oci:compute`])\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\",tags]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Oracle VM OS\", id\n]\n| summarize count = count()\n| fields concat(count, \"‚ö†Ô∏è\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"‚ö†Ô∏è\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"133":{"title":"Hosts","type":"data","query":"fetch dt.entity.host, from: -15m\n| fieldsAdd osVersion, managementZones, hostGroupName, tags, softwareObsolescenceManagement = entity.name\n| filter isNotNull(osVersion) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Operating Systems\", $Coverage)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.os-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:osVersion,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd stringifiedOs = if(isNull(event.os), \"null\", else: event.os)\n| filter in(\"null\", $OperatingSystems) OR in(stringifiedOs, $OperatingSystems)\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), osVersion, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), osVersion, from: 0) +\n        stringLength(osVersion) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), osVersion, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(timeBeforeObsolescence), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| fields Status, Host = entity.name, `Host Group` = hostGroupName, `Management Zones` = managementZones, `Tags` = tags, OS = event.os, `Running Version` = event.currentVersion, `Full Name` = osVersion, LTS = event.lts, Cycle = event.currentCycle, `Cycle Published At` = substring(event.currentCyclePublishedAt, to:10), `End of Life` = event.eol, `Extended Support`, `Max Age` = age, `Time Before Obsolescence` = timeBeforeObsolescence, `Latest Version` = event.latestVersion, `Published at` = substring(event.latestVersionPublishedAt, to:10), Link = event.link, id\n| sort `Time Before Obsolescence` ASC\n| append [ // VMWare\n  //from classic integration\n  fetch dt.entity.virtualmachine, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host], ipAddress, cloudTags=tags, datacenterId=belongs_to[dt.entity.vmware_datacenter]\n  //match with OneAgent hosts\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | lookup [fetch dt.entity.vmware_datacenter], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n    ipAddress = if(monitored, host.ipAddress, else:ipAddress), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"),\n    tags=arrayConcat(host.tags,cloudTags), datacenter=datacenter.entity.name, datacenter.id=datacenterId\n  //add extension VMs\n  | append [ fetch `dt.entity.vmware:virtualmachine`\n    | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n    | fieldsAdd host=arrayFirst(same_as[dt.entity.host]), ipAddress=vm_ip_address, cloudTags=array()\n    | lookup [fetch dt.entity.host | fieldsadd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\" //match with OneAgent hosts\n    | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n    | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n      ipAddress = if(monitored, host.ipAddress, else:ipAddress), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(host.tags,cloudTags)]\n  //add OneAgent VMware hosts\n  | append [ fetch dt.entity.host\n    | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n    | filter isNotNull(monitoringMode) AND hypervisorType == \"VMWARE\" AND isNull(runs_on[dt.entity.virtualmachine])\n    | fieldsAdd datacenterId=belongs_to[dt.entity.geoloc_site]\n    | lookup [fetch dt.entity.geoloc_site], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\", tags, datacenter=datacenter.entity.name, datacenter.id=datacenterId]\n  | dedup id\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown VMWare VM OS\", id\n]\n| append [ // AWS\n  fetch dt.entity.ec2_instance, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host], ipAddress=arrayConcat(if(isNotNull(localIp), array(localIp), else: array()), if(isNotNull(publicIp), array(publicIp), else: array())),\n    cloudMonitored=isNotNull(accessible_by[dt.entity.aws_credentials]), cloudTags=tags, datacenterId=belongs_to[dt.entity.aws_availability_zone]\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | lookup [fetch dt.entity.aws_availability_zone], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n  | fieldsAdd oneAgentMonitored=not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(oneAgentMonitored, host.id, else:id), entity.name=if(oneAgentMonitored, host.entity.name, else:entity.name),\n    ipAddress=if(oneAgentMonitored, host.ipAddress, else:ipAddress), monitoringStatus=if(oneAgentMonitored AND cloudMonitored,\"FULL\", else:if(oneAgentMonitored, \"OA\", else:\"CLOUD\")),\n    tags=arrayConcat(host.tags,cloudTags), datacenter=datacenter.entity.name, datacenter.id=datacenterId\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown AWS VM OS\", id\n]\n| append [ // GCP\n  fetch `dt.entity.cloud:gcp:gce_instance`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host][0], cloudTags=tags, zone\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], lookupField: id, sourceField:host, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"),\n    tags=arrayConcat(cloudTags,host.tags), datacenter=zone\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND cloudType == \"GOOGLE_CLOUD_PLATFORM\" AND isNull(runs_on[`dt.entity.cloud:gcp:gce_instance`])\n    | fieldsAdd datacenterId=belongs_to[dt.entity.gcp_zone]\n    | lookup [fetch dt.entity.gcp_zone], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n    | fields id, entity.name, ipAddress, monitoringStatus=\"OA\", tags, datacenter=datacenter.entity.name, datacenter.id=datacenterId]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown GCP VM OS\", id\n]\n| append [ // Azure\n  fetch dt.entity.azure_vm, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host], ipAddress, cloudMonitored=isNotNull(accessible_by[dt.entity.azure_subscription]),\n    cloudTags=tags, datacenterId=belongs_to[dt.entity.azure_region]\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | lookup [fetch dt.entity.azure_region], sourceField:datacenterId, lookupField:id, prefix:\"datacenter.\"\n  | fieldsAdd oneAgentMonitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(oneAgentMonitored, host.id, else:id), entity.name=if(oneAgentMonitored, host.entity.name, else:entity.name),\n    ipAddress = if(oneAgentMonitored, host.ipAddress, else:ipAddress), monitoringStatus=if(oneAgentMonitored AND cloudMonitored, \"FULL\", else: if(oneAgentMonitored, \"OA\", else: \"CLOUD\")),\n    tags=arrayConcat(host.tags,cloudTags), datacenter=datacenter.entity.name, datacenter.id=datacenterId\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Azure VM OS\", id\n]\n| append [ // Hyper-V\n  fetch `dt.entity.hyperv:virtual_machine`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=same_as[dt.entity.host][0], ip_address, cloudTags=tags\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n    ipAddress = if(monitored, host.ipAddress, else:ip_address), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(host.tags,cloudTags)\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND hypervisorType == \"HYPER_V\" AND cloudType != \"AZURE\" AND isNull(same_as[`dt.entity.hyperv:virtual_machine`])\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\", tags]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Hyper-V VM OS\", id\n]\n| append [ // Nutanix\n  fetch `dt.entity.nutanix:vm`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=same_as[dt.entity.host][0], IpAddress, cloudTags=tags\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], sourceField:host, lookupField:id, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),\n    ipAddress = if(monitored, host.ipAddress, else:IpAddress), monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(host.tags,cloudTags)\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND hypervisorType == \"AHV\" AND isNull(same_as[`dt.entity.nutanix:vm`])\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\", tags]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Nutanix VM OS\", id\n]\n| append [ // Oracle\n  fetch `dt.entity.cloud:oci:compute`, from: -15m\n  | filter in(\"‚ö†Ô∏è Missing OneAgent\", $Status) AND $MZ == \"Any\" AND $Tag == \"Any\" AND in(\"Operating Systems\", $Coverage) AND in(\"null\", $OperatingSystems)\n  | fieldsAdd host=runs[dt.entity.host][0], cloudTags=tags\n  | lookup [fetch dt.entity.host | fieldsAdd isMonitoringCandidate, tags], lookupField: id, sourceField:host, prefix:\"host.\"\n  | fieldsAdd monitored = not(isTrueOrNull(host.isMonitoringCandidate))\n  | fields id=if(monitored, host.id, else:id), entity.name=if(monitored, host.entity.name, else:entity.name),monitoringStatus=if(monitored, \"FULL\", else:\"CLOUD\"), tags=arrayConcat(cloudTags,host.tags)\n  | append [ fetch dt.entity.host\n    | filter isNotNull(monitoringMode) AND cloudType == \"ORACLE\" AND isNull(runs_on[`dt.entity.cloud:oci:compute`])\n    | fields id,entity.name,ipAddress,monitoringStatus=\"OA\",tags]\n  | filter matchesValue(monitoringStatus, \"CLOUD\")\n  | fields Status = \"‚ö†Ô∏è Missing OneAgent\", Host = entity.name, `Full Name` =\"Unknown Oracle VM OS\", id\n]","visualization":"table","visualizationSettings":{"table":{"linewrapEnabled":true,"sortBy":{"columnId":"[\"Status\"]","direction":"descending"},"columnWidths":{"[\"OS\"]":145.9479217529297,"[\"Status\"]":149.61459350585938,"[\"managementZones\"]":176.69793701171875,"[\"tags\"]":157,"[\"Host\"]":214.90625,"[\"Full Name\"]":411.01043701171875}},"autoSelectVisualization":false,"thresholds":[]},"querySettings":{"maxResultRecords":100000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":100,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}},"segments":{"tileSegments":[],"tileSegmentsEnabled":false}},"134":{"type":"markdown","content":"# "},"135":{"title":"","type":"code","input":"export default async function() {\n  return 'Technologies';\n}","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"element","recordField":"element","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"136":{"title":"Obsolete Technology Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü† Obsolete\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü† Obsolete\")\n| summarize count = count()\n| fields concat(count, \"üü†\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü†\")","prefixIcon":"ApplicationObservabilitySignetIcon","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"137":{"title":"Processes with Obsolete Technology Versions","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü† Obsolete\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü† Obsolete\")\n| summarize count = countDistinct(id)\n| fields concat(count, \"üü†\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü†\")","prefixIcon":"ApplicationObservabilitySignetIcon","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"138":{"title":"Technologies","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü† Obsolete\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| fields Status, Process, `Management Zones` = managementZones, `Tags` = tags, Technology, Edition, `Running Version` = Version, LTS = event.lts, Cycle = event.currentCycle, `Cycle Published At` = substring(event.currentCyclePublishedAt, to:10), `End of Life` = event.eol, `Max Age` = age, `Time Before Obsolescence` = timeBeforeObsolescence, `Latest Version` = event.latestVersion, `Published at` = substring(event.latestVersionPublishedAt, to:10), Link = event.link, id\n| filter isNotNull(Technology)\n| summarize countDistinct(Technology)","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"Technology Count","recordField":"countDistinct(Technology)","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[{"identifier":"countDistinct(Technology)","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1740152485154}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"139":{"title":"Technology Version Distribution","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| summarize by:{Status, Technology, Edition, Version, timeBeforeObsolescence}, count = count()\n| fields Status, `Process Count` = count, `Time Before Obsolescence` = timeBeforeObsolescence, Technology, Edition, Version\n| sort `Time Before Obsolescence` ASC, `Process Count` DESC","visualization":"table","visualizationSettings":{"table":{"sortBy":{"columnId":"[\"Technology\"]","direction":"unset"},"columnWidths":{"[\"id\"]":37,"[\"entity.name\"]":319.2632751464844,"[\"Edition\"]":199.36553192138672,"[\"Version\"]":125.23106384277344,"[\"Process Group\"]":403.2632751464844,"[\"Process\"]":631,"[\"Status\"]":197.03125,"[\"Technology\"]":227.73959350585938}},"thresholds":[]},"querySettings":{"maxResultRecords":100000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":100,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"140":{"title":"Unique Versions","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü† Obsolete\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| summarize by:{Status, Technology, Edition, Version}, count = count()\n| fields Status, `Process Count` = count, Technology, Edition, Version\n| filter isNotNull(Technology)\n| summarize count()","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"Technology Count","recordField":"count()","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[{"identifier":"count()","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1740152491175}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"141":{"title":"Processes with Updatable Technology Versions","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü° Updatable\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü° Updatable\")\n| summarize count = countDistinct(id)\n| fields concat(count, \"üü°\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü°\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"142":{"title":"Updatable Technology Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü° Updatable\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü° Updatable\")\n| summarize count = count()\n| fields concat(count, \"üü°\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü°\")","prefixIcon":"","trend":{"isVisible":true}},"autoSelectVisualization":false,"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"143":{"title":"Up-To-Date Technology Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü¢ Up-to-date\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü¢ Up-to-date\")\n| summarize count = count()\n| fields concat(count, \"üü¢\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü¢\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"144":{"title":"Processes with Up-To-Date Technology Versions","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü¢ Up-to-date\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü¢ Up-to-date\")\n| summarize count = countDistinct(id)\n| fields concat(count, \"üü¢\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü¢\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"145":{"title":"Processes","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü† Obsolete\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| fields Status, Process, `Management Zones` = managementZones, `Tags` = tags, Technology, Edition, `Running Version` = Version, LTS = event.lts, Cycle = event.currentCycle, `Cycle Published At` = substring(event.currentCyclePublishedAt, to:10), `End of Life` = event.eol, `Max Age` = age, `Time Before Obsolescence` = timeBeforeObsolescence, `Latest Version` = event.latestVersion, `Published at` = substring(event.latestVersionPublishedAt, to:10), Link = event.link, id\n| summarize countDistinct(id)","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"Process Count","recordField":"countDistinct(id)","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[{"identifier":"countDistinct(id)","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1728215429229}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"146":{"title":"Technology Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"üü† Obsolete\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| fields Status, Process, `Management Zones` = managementZones, `Tags` = tags, Technology, Edition, `Running Version` = Version, LTS = event.lts, Cycle = event.currentCycle, `Cycle Published At` = substring(event.currentCyclePublishedAt, to:10), `End of Life` = event.eol, `Max Age` = age, `Time Before Obsolescence` = timeBeforeObsolescence, `Latest Version` = event.latestVersion, `Published at` = substring(event.latestVersionPublishedAt, to:10), Link = event.link, id\n| summarize count()","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"Process Count","recordField":"count()","prefixIcon":"","trend":{"isVisible":true}},"autoSelectVisualization":false,"thresholds":[],"unitsOverrides":[{"identifier":"count()","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1728215429229}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"147":{"title":"Processes with Undocumented Technology Versions","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"‚ö™ Undocumented\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"‚ö™ Undocumented\")\n| summarize count = countDistinct(id)\n| fields concat(count, \"‚ö™\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"‚ö™\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"148":{"title":"Undocumented Technology Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter in(\"‚ö™ Undocumented\", $Status) AND (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"‚ö™ Undocumented\")\n| summarize count = count()\n| fields concat(count, \"‚ö™\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"‚ö™\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"149":{"title":"Technology Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| fieldsAdd Process = entity.name, softwareTechnologies, managementZones, tags, softwareObsolescenceManagement = entity.name\n| filter (in($MZ, managementZones) OR $MZ == \"Any\") AND (in($Tag, tags) OR $Tag == \"Any\") AND in(\"Technologies\", $Coverage)\n| expand softwareTechnologies\n| parse softwareTechnologies, \"'type:' LD:Technology ',edition:' LD:Edition ',version:' LD:Version\"\n| filter Technology != \"DYNATRACE\" AND (in(\"null\", $Technologies) OR in(Technology, $Technologies))\n| fieldsAdd key = concat(Technology, \":\", Edition, \":\", Version)\n| fieldsAdd result = lookup([\n  fetch events, from: -7d\n  | filter dt.system.bucket == \"default_davis_custom_events\"\n  | filter event.name == \"software-obsolescence-management.technology-info\"\n  | sort timestamp DESC\n  ],\n  sourceField:key,\n  lookupField:key\n)\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd `Extended Support` = if(\n  ((indexOf(toString(array($SupportOverrides)), key, from: 0) >= 0) AND (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) >= 0)),\n  substring(\n      toString(array($SupportOverrides)),\n      from: (\n        (indexOf(toString(array($SupportOverrides)), key, from: 0) +\n        stringLength(key) +\n        5)\n      ),\n      to: (indexOf(toString(array($SupportOverrides)), \"}\", from: indexOf(toString(array($SupportOverrides)), key, from: 0)) - 2)\n    ),\n    else: null\n)\n| fieldsAdd age = now() - toTimestamp(event.currentCyclePublishedAt)\n| fieldsAdd timeBeforeObsolescence = toTimestamp(if(isNotNull(`Extended Support`), `Extended Support`, else: event.eol)) - now()\n| fieldsAdd Status = if(timeBeforeObsolescence < toDuration(0), \"üü† Obsolete\")\n| fieldsAdd Status = if(isNull(Status) AND event.currentVersion == event.latestVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND (isNotNull(timeBeforeObsolescence) OR (event.currentVersion != event.latestVersion AND isNotNull(event.currentVersion) AND event.currentVersion != \"null\" AND isNotNull(event.latestVersion))), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| fields key, Status, Process, `Management Zones` = managementZones, `Tags` = tags, Technology, Edition, `Running Version` = Version, LTS = event.lts, Cycle = event.currentCycle, `Cycle Published At` = substring(event.currentCyclePublishedAt, to:10), `End of Life` = event.eol, `Max Age` = age, `Time Before Obsolescence` = timeBeforeObsolescence, `Latest Version` = event.latestVersion, `Published at` = substring(event.latestVersionPublishedAt, to:10), Link = event.link, id\n| sort `Time Before Obsolescence` ASC, Technology ASC","visualization":"table","visualizationSettings":{"table":{"sortBy":{"columnId":"[\"Status\"]","direction":"unset"},"columnWidths":{"[\"id\"]":37,"[\"entity.name\"]":319.2632751464844,"[\"Edition\"]":199.36553192138672,"[\"Version\"]":125.23106384277344,"[\"Process Group\"]":403.2632751464844,"[\"Process\"]":246,"[\"Status\"]":135.03125,"[\"Technology\"]":189.73959350585938,"[\"Management Zones\"]":259.625,"[\"Tags\"]":159}},"thresholds":[]},"querySettings":{"maxResultRecords":100000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":100,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"150":{"type":"markdown","content":"# "},"151":{"title":"","type":"code","input":"export default async function() {\n  return 'Libraries';\n}","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"element","recordField":"element","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"152":{"title":"Library Version Distribution","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize by:{Status, Technology, Library, Version}, count = count()\n| fields Status, `Process Count` = count, Technology, Library, Version\n| sort Status ASC, `Process Count` DESC","visualization":"table","visualizationSettings":{"table":{"sortBy":{"columnId":"[\"Top Vulnerability\"]","direction":"ascending"},"columnWidths":{"[\"File name\"]":249.2291717529297,"[\"Library\"]":540.03125,"[\"Latest Stable Version\"]":98.82292175292969,"[\"Running Version\"]":143.6041717529297,"[\"Link\"]":349.53125,"[\"Description\"]":196.125}},"thresholds":[]},"querySettings":{"maxResultRecords":100000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":100,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"153":{"title":"Vulnerable Library Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"üî¥ Vulnerable\", $Status) AND in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üî¥ Vulnerable\")\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize count = count()\n| fields concat(count, \"üî¥\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üî¥\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"154":{"title":"Processes with Vulnerable Library Versions","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"üî¥ Vulnerable\", $Status) AND in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üî¥ Vulnerable\")\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize count = countDistinct(id)\n| fields concat(count, \"üî¥\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üî¥\")","prefixIcon":"","trend":{"isVisible":true}},"autoSelectVisualization":false,"thresholds":[],"unitsOverrides":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"155":{"title":"Libraries","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize countDistinct(Library)","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"libraryCount","recordField":"countDistinct(Library)","prefixIcon":"","trend":{"isVisible":true}},"autoSelectVisualization":false,"thresholds":[],"unitsOverrides":[{"identifier":"countDistinct(Library)","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1740152521161}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":100,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"156":{"title":"Updatable Library Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"üü° Updatable\", $Status) AND in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü° Updatable\")\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize count = count()\n| fields concat(count, \"üü°\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü°\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"157":{"title":"Processes with Updatable Library Versions","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"üü° Updatable\", $Status) AND in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü° Updatable\")\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize count = countDistinct(id)\n| fields concat(count, \"üü°\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü°\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"158":{"title":"Library Versions","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize by:{Status, Technology, Library, Version}, count = count()\n| fields Status, `Process Count` = count, Technology, Library, Version\n| summarize count()","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"libraryVersionCount","recordField":"count()","prefixIcon":"","trend":{"isVisible":true}},"autoSelectVisualization":false,"thresholds":[],"unitsOverrides":[{"identifier":"count()","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1740152527296}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"159":{"title":"Up-To-Date Library Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"üü¢ Up-to-date\", $Status) AND in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü¢ Up-to-date\")\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize count = count()\n| fields concat(count, \"üü¢\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü¢\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"160":{"title":"Processes with Up-To-Date Library Versions","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"üü¢ Up-to-date\", $Status) AND in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"üü¢ Up-to-date\")\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize count = countDistinct(id)\n| fields concat(count, \"üü¢\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"üü¢\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"161":{"title":"Processes with Detected Library","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize countDistinct(id)","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"libraryVersionCount","recordField":"countDistinct(id)","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[{"identifier":"countDistinct(id)","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1740152533621}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"162":{"title":"Undocumented Library Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"‚ö™ Undocumented\", $Status) AND in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"‚ö™ Undocumented\")\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize count = count()\n| fields concat(count, \"‚ö™\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"‚ö™\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"163":{"title":"Processes with Undocumented Library Versions","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"‚ö™ Undocumented\", $Status) AND in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, \"‚ö™ Undocumented\")\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize count = countDistinct(id)\n| fields concat(count, \"‚ö™\")","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"sum","recordField":"concat(count, \"‚ö™\")","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[{"identifier":"libraryInstanceCount","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1740153091058}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"164":{"title":"Library Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| summarize count()","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"libraryVersionCount","recordField":"count()","prefixIcon":"","trend":{"isVisible":true}},"thresholds":[],"unitsOverrides":[{"identifier":"count()","unitCategory":"unspecified","baseUnit":"none","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1740152394297}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"165":{"title":"Library Instances","type":"data","query":"fetch dt.entity.process_group_instance, from: -15m\n| expand softwareComponentId = asRecord(contains)[`dt.entity.software_component`] // This relationship retrieves a maximum 100 entities\n| dedup softwareComponentId\n| lookup [\n  fetch dt.entity.software_component, from: -15m\n  | fields entity.name, id, softwareComponentType, softwareComponentVersion, belongs_to\n],\n  sourceField:softwareComponentId,\n  lookupField:id,\n  executionOrder: leftFirst\n| fieldsAdd lastColonIndex = lastIndexOf(lookup.entity.name, \":\"), softwareObsolescenceManagement = lookup.entity.name\n| fieldsAdd Technology = lookup.softwareComponentType\n| fieldsAdd Library = substring(lookup.entity.name, to:lastColonIndex)\n| fieldsAdd Version = lookup.softwareComponentVersion\n| filter in(\"Libraries\", $Coverage) AND (in(\"null\", $Technologies) OR in(lookup.softwareComponentType, $Technologies)) AND (in(\"null\", $Libraries) OR in(Library, $Libraries))\n| fieldsAdd result = lookup([\n      fetch events, from: -7d\n      | filter dt.system.bucket == \"default_davis_custom_events\"\n      | filter event.name == \"software-obsolescence-management.library-info\"\n      | fields timestamp, key, currentVersionPublishedAt, currentVersion, latestStableVersion, latestStableVersionPublishedAt, licenses, link\n      | sort timestamp DESC\n      | limit 100000\n    ],\n    sourceField:lookup.entity.name,\n    lookupField:key)\n| fieldsAdd `Top Vulnerability` = lookup([\n      fetch events, from: -15m\n      | filter event.provider==\"Dynatrace\"\n      | filter event.type==\"VULNERABILITY_STATE_REPORT_EVENT\"\n      | filter event.level==\"VULNERABILITY\"\n      | expand softwareComponentId = affected_entities.vulnerable_components.ids\n      | fields softwareComponentId, vulnerability.davis_assessment.score\n      | sort vulnerability.davis_assessment.score DESC\n      | dedup softwareComponentId\n      | limit 100000\n    ],\n    sourceField:softwareComponentId,\n    lookupField:softwareComponentId)\n| fieldsAdd `Vulnerability Score` = `Top Vulnerability`[vulnerability.davis_assessment.score]\n| fieldsFlatten result, prefix:\"event.\"\n| fieldsAdd age = now() - toTimestamp(event.currentVersionPublishedAt)\n| fieldsAdd Status = if(isNotNull(`Top Vulnerability`), \"üî¥ Vulnerable\")\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion) AND event.currentVersion == event.latestStableVersion, \"üü¢ Up-to-date\", else: Status)\n| fieldsAdd Status = if(isNull(Status) AND isNotNull(event.currentVersion) AND isNotNull(event.latestStableVersion), \"üü° Updatable\", else: Status)\n| fieldsAdd Status = if(isNull(Status), \"‚ö™ Undocumented\", else: Status)\n| filter in(Status, $Status)\n| expand id = lookup.belongs_to[dt.entity.process_group_instance] // This relationship retrieves a maximum 100 entities\n| fieldsAdd pg = if($MZ == \"Any\" AND $Tag == \"Any\", null, else: lookup([\n      fetch dt.entity.process_group_instance, from: -15m\n      | fields id, managementZones, tags\n      | filter ($MZ == \"Any\" OR in($MZ, managementZones)) AND ($Tag == \"Any\" OR in($Tag, tags))\n      | limit 100000\n    ],\n    sourceField:id,\n    lookupField:id)\n    )\n| fieldsFlatten pg, prefix:\"pgi.\"\n| filter ($MZ == \"Any\" OR in($MZ, pgi.managementZones)) AND ($Tag == \"Any\" OR in($Tag, pgi.tags))\n| fields Status, Technology, Library, `Running Version` = Version, `Published At` = substring(event.currentVersionPublishedAt, to:10), `Latest Stable Version` = event.latestStableVersion, `Published at` = substring(event.latestStableVersionPublishedAt, to:10), Age = age, `Top Vulnerability`, `Vulnerability Score`, Licenses = event.licenses, Link = event.link, id\n| sort Status DESC, `Vulnerability Score` DESC, Technology ASC, Library ASC","visualization":"table","visualizationSettings":{"table":{"sortBy":{"columnId":"[\"Top Vulnerability\"]","direction":"descending"},"columnWidths":{"[\"File name\"]":249.2291717529297,"[\"Library\"]":194.03125,"[\"Latest Stable Version\"]":98.82292175292969,"[\"Running Version\"]":143.6041717529297,"[\"Link\"]":349.53125,"[\"Description\"]":196.125,"[\"Status\"]":160.1354217529297}},"thresholds":[]},"querySettings":{"maxResultRecords":100000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":100,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"now()-2h","to":"now()"}}},"166":{"type":"markdown","content":"# "},"167":{"title":"","type":"code","input":"export default async function() {\n  return 'Platform usage of the Software Obsolescence Management solution';\n}","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"element","recordField":"element","trend":{"isVisible":true}},"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false}},"168":{"title":"Scanned bytes per component of the Software Obsolescence Management solution","type":"data","query":"fetch dt.system.events\n| filter contains(query_string, \"softwareObsolescenceManagement\") AND scanned_bytes != 0\n| fields timestamp, component = if(client.application_context == \"dynatrace.dashboards\", \"Dashboard\", else: \"Workflow\"), scanned_bytes\n| makeTimeseries `Scanned bytes` = sum(scanned_bytes), by:{component}, interval: 1h","visualization":"barChart","visualizationSettings":{"dataMapping":{"displayedFields":["component"]},"chartSettings":{"truncationMode":"middle","xAxisLabel":"timeframe","xAxisScaling":"analyzedTimeframe","fieldMapping":{"leftAxisValues":["Scanned bytes"],"timestamp":"timeframe"}},"autoSelectVisualization":false,"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframeEnabled":true,"tileTimeframe":{"from":"@d","to":"now()"}},"segments":{"tileSegments":[],"tileSegmentsEnabled":false}},"169":{"title":"Total scanned bytes by the Software Obsolescence Management solution","type":"data","query":"fetch dt.system.events\n| filter contains(query_string, \"softwareObsolescenceManagement\")\n| fields timestamp, component = if(client.application_context == \"dynatrace.dashboards\", \"Dashboard\", else: \"Workflow\"), scanned_bytes\n| summarize sum(scanned_bytes)","visualization":"singleValue","visualizationSettings":{"singleValue":{"labelMode":"none","label":"query_id","recordField":"sum(scanned_bytes)","prefixIcon":"DqlSignetIcon","sparklineSettings":{"record":"sum(scanned_bytes)"},"trend":{"isVisible":true}},"autoSelectVisualization":false,"thresholds":[],"unitsOverrides":[{"identifier":"sum(scanned_bytes)","unitCategory":"data","baseUnit":"byte","displayUnit":null,"decimals":0,"suffix":"","delimiter":false,"added":1741649267987}]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframe":{"from":"now()-2h","to":"now()"},"tileTimeframeEnabled":false},"segments":{"tileSegments":[],"tileSegmentsEnabled":false}},"170":{"title":"DQL queries per component of the Software Obsolescence Management solution","type":"data","query":"fetch dt.system.events\n| filter contains(query_string, \"softwareObsolescenceManagement\") AND scanned_bytes != 0\n| fields timestamp, component = if(client.application_context == \"dynatrace.dashboards\", \"Dashboard\", else: \"Workflow\"), scanned_bytes\n| makeTimeseries `Query count` = count(), by:{component}, interval: 1h","visualization":"barChart","visualizationSettings":{"dataMapping":{"displayedFields":["component"]},"chartSettings":{"truncationMode":"middle","xAxisLabel":"timeframe","xAxisScaling":"analyzedTimeframe","fieldMapping":{"leftAxisValues":["Query count"],"timestamp":"timeframe"}},"autoSelectVisualization":false,"thresholds":[]},"querySettings":{"maxResultRecords":1000,"defaultScanLimitGbytes":500,"maxResultMegaBytes":1,"defaultSamplingRatio":10,"enableSampling":false},"davis":{"enabled":false,"davisVisualization":{"isAvailable":true}},"timeframe":{"tileTimeframe":{"from":"now()-2h","to":"now()"},"tileTimeframeEnabled":false},"segments":{"tileSegments":[],"tileSegmentsEnabled":false}},"171":{"type":"markdown","content":"##### Version: 1.3.1\n###### Author: Thomas Contassot\n###### Links:\n- [GitHub](https://github.com/dynatrace-oss/CustomerSuccess/tree/main/Software%20Obsolescence%20Management)\n- [Request For Enhancement](https://dt-url.net/som-rfe)\n###### Credits:\n- [endoflife.date](https://endoflife.date) (for OS and Technology obsolescence data)\n- [deps.dev](https://deps.dev) (for Library obsolescence data)\n- [Dynatrace AppSec](https://docs.dynatrace.com/docs/secure/application-security/vulnerability-analytics/vulnerabilities) (for Vulnerability insights)\n###### Changelog from 1.3.x:\n- Fully compatible with segment filtering\n- Now listing all Management Zones in the MZ variable instead of the first 100 entries\n- New filter to select which types of entities to analyse (OS, Technologies, Libraries)\n- New filter to select which Operating Systems to analyse in the Operating Systems section\n- New filter to select which Technologies to analyse in the Technologies and Libraries sections\n- New filter to select which Libraries to analyse in the Libraries section\n- Removed Dynatrace components from the analysis (already available in the DTR)\n- Updated instructions to update the dashboard without changing its ID\n- Bug fix concerning the capture of OS and technology obsolescence\n- Optimized lookups in library tiles to scale up to 100,000 library versions\n- More robust RHEL identification\n- Instant loading of OperatingSystems, Technolgies and Libraries variables at any scale"},"172":{"type":"markdown","content":"##### Instructions\n###### Installation:\n1. Download from [GitHub](https://github.com/dynatrace-oss/CustomerSuccess/tree/main/Software%20Obsolescence%20Management) and [upload](https://docs.dynatrace.com/docs/analyze-explore-automate/dashboards-and-notebooks/dashboards-new/get-started/dashboards-use#dashboards-upload) the Dashboard's JSON to visualize the results of the continuous analysis (you've probably already done that)\n2. Download from [GitHub](https://github.com/dynatrace-oss/CustomerSuccess/tree/main/Software%20Obsolescence%20Management) and [upload](https://docs.dynatrace.com/docs/analyze-explore-automate/workflows/manage-workflows/workflows-upload) the workflow template's YAML to keep refreshing obsolescence data\n3. The workflow runs by default every 2mn from 4 to 6AM (UTC), 7 days a week. To optimize the cost of the solution, you can reduce its frequency, depending on the amount of entities in your tenant. Simply make sure it fully scans all entities at least once a week to guarantee the complete obsolescence analysis of your software inventory. The workflow starts a new scan cycle each Monday morning until the following Sunday. Each hour of running workflow, it reviews an additional 1000 OS versions, technology versions and library versions detected in your tenant. Do the math based based on the number of distinct OS/technology/library versions detected in your tenant to optimize how many hours you need the workflow to run each week.\n4. [Allow outbound connections](https://developer.dynatrace.com/develop/app-functions/allow-outbound-connections) to 'endoflife.date' and 'api.deps.dev' domains in the tenant's settings\n5. The dashboard will show exhaustive results at the end of the first full data refresh cycle (cf. step 2). Wait up to 24h to ensure the completeness of the obsolescence analysis.\n6. By default, the workflow is configured to raise a CUSTOM_INFO event on hosts 30 days before the obsolescence of their OS and another CUSTOM_INFO event when it's obsolete as a reminder to upgrade it before it impacts your security posture. To raise the awareness even more, open the JS code of the workflow and configure its variable \"alertThresholds\" so that a CUSTOM_ALERT problem is open in Dynatrace instead of just CUSTOM_INFO events attached to hosts. The same variable also lets you disable such event/alert automation, if needed. Review the top workflow code comments as other variables let you scope such alerting by tags and management zones.\n7. Some technologies still have no proper obsolescence documentation? Your organization got custom support extensions? You can answer those situations by providing your very own list of OS or technology support overrides in the \"SupportOverrides\" dashboard variable. Just edit it by following instructions in its code comment. Same edits must be replicated in the workflow's code to avoid false positive alerts.\n8. Make sure your Management Zones, Tags and/or Segments include the Hosts and Process Group Instances relevant to each perimeter\n###### Usage:\n- Scope the audit by Segment, Management Zone or Tag\n- Filter by obsolescence statuses\n- Filter by Operating Systems, Technologies and Libraries\n- Prioritize your maintenance by vulnerability and obsolescence risk, criticity and radius of the affected software components\n- Share the filtered view's URL to the responsible team so that they keep their software safe and supported\n- Navigate to the associated entity by clicking any entry in the full-detail tables and then on \"Open record with\"\n- Extend your OneAgent coverage to reduce obsolescence risks. The [Discovery mode](https://www.dynatrace.com/platform/infrastructure-observability/foundation-and-discovery/) + [Code Module injection](https://docs.dynatrace.com/docs/observe/infrastructure-monitoring/hosts/monitoring-modes#code-module-injection) are sufficient for that capability.\n- [Activate AppSec](https://docs.dynatrace.com/docs/secure/application-security/application-protection) to reduce security risks from vulnerabilities. The [Discovery mode](https://www.dynatrace.com/platform/infrastructure-observability/foundation-and-discovery/) + [Code Module injection](https://docs.dynatrace.com/docs/observe/infrastructure-monitoring/hosts/monitoring-modes#code-module-injection) are sufficient for that capability.\n- Update the \"SupportOverrides\" variable with your own support terms (cf. installation step 7)\n- Track the solution's usage of the platform to understand and optimize its cost\n###### Update:\n1. Download the new JSON files whenever a new version is published in the open source GitHub repo\n2. Follow the installation instructions from the latest version\n3. Remove the previous version of the Workflow from your tenant\n4. Either perform the same as step 3. for the previous dashboard or copy and paste the tiles from the new version into the previous dashboard to keep using the same dashboard ID which you probably already shared with your teammates."}},"layouts":{"120":{"x":12,"y":0,"w":12,"h":2},"121":{"x":0,"y":0,"w":12,"h":2},"122":{"x":0,"y":2,"w":24,"h":1},"123":{"x":0,"y":3,"w":24,"h":1},"124":{"x":8,"y":4,"w":16,"h":10},"125":{"x":0,"y":4,"w":4,"h":3},"126":{"x":4,"y":4,"w":4,"h":2},"127":{"x":4,"y":6,"w":4,"h":2},"128":{"x":0,"y":7,"w":4,"h":3},"129":{"x":4,"y":8,"w":4,"h":2},"130":{"x":4,"y":10,"w":4,"h":2},"131":{"x":0,"y":10,"w":4,"h":4},"132":{"x":4,"y":12,"w":4,"h":2},"133":{"x":0,"y":14,"w":24,"h":8},"134":{"x":0,"y":22,"w":24,"h":1},"135":{"x":0,"y":23,"w":24,"h":1},"136":{"x":8,"y":24,"w":4,"h":2},"137":{"x":4,"y":24,"w":4,"h":2},"138":{"x":0,"y":24,"w":4,"h":2},"139":{"x":12,"y":24,"w":12,"h":8},"140":{"x":0,"y":26,"w":4,"h":2},"141":{"x":4,"y":26,"w":4,"h":2},"142":{"x":8,"y":26,"w":4,"h":2},"143":{"x":8,"y":28,"w":4,"h":2},"144":{"x":4,"y":28,"w":4,"h":2},"145":{"x":0,"y":28,"w":4,"h":2},"146":{"x":0,"y":30,"w":4,"h":2},"147":{"x":4,"y":30,"w":4,"h":2},"148":{"x":8,"y":30,"w":4,"h":2},"149":{"x":0,"y":32,"w":24,"h":8},"150":{"x":0,"y":40,"w":24,"h":1},"151":{"x":0,"y":41,"w":24,"h":1},"152":{"x":12,"y":42,"w":12,"h":8},"153":{"x":8,"y":42,"w":4,"h":2},"154":{"x":4,"y":42,"w":4,"h":2},"155":{"x":0,"y":42,"w":4,"h":2},"156":{"x":8,"y":44,"w":4,"h":2},"157":{"x":4,"y":44,"w":4,"h":2},"158":{"x":0,"y":44,"w":4,"h":2},"159":{"x":8,"y":46,"w":4,"h":2},"160":{"x":4,"y":46,"w":4,"h":2},"161":{"x":0,"y":46,"w":4,"h":2},"162":{"x":8,"y":48,"w":4,"h":2},"163":{"x":4,"y":48,"w":4,"h":2},"164":{"x":0,"y":48,"w":4,"h":2},"165":{"x":0,"y":50,"w":24,"h":8},"166":{"x":0,"y":58,"w":24,"h":1},"167":{"x":0,"y":59,"w":24,"h":1},"168":{"x":8,"y":60,"w":16,"h":4},"169":{"x":0,"y":60,"w":8,"h":8},"170":{"x":8,"y":64,"w":16,"h":4},"171":{"x":0,"y":68,"w":12,"h":10},"172":{"x":12,"y":68,"w":12,"h":10}},"importedWithCode":true,"settings":{"defaultTimeframe":{"value":{"from":"now()-7d","to":"now()"},"enabled":true}}}